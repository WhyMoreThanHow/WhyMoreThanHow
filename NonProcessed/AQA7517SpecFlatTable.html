<!DOCTYPE html>
<html>
<!-- Content (c) AQA 2021 - flattening and reference designation MwtH-->

<head>

<style>
body{bg-color: powderblue; font-family: verdana; margin: 40px;}
table, th, td{border: 1px solid blue; border-collapse: collapse;
th{text-align: left;}
</style>

</head>

<body>
<h2> AQA7517 Specification - manually flattened by WmtH </h2>

<p>   Do not totally rely on this. Specifications can change and mistakes/interpretations will be present. </p>

<p> Suggest you use CTRL F to look for things.<br>
    <small>The reference on the left is indicating how nested any line is - not as easy to read as the specification but at least it is 
    tablular rather than the inconsistent hierarchy of graphically nested levels and mix between 'Content' and 'Additional Information' 
    in the AQA specification. The 4 prefix is my code for this course rather than the AS AQA7516. "x+" indicates an elaboration at 
    a sub-level to the previous entry. <br>
    This is here for re-working - my intention is eventually to put this into graphical database (Neo4j) to find and add paths between 
    specification components. </small></p>



<table style="width:90%">
  <tr>
    <th>AQA7517</th>
    <th>Text</th>
  </tr>
  <tr>
    <td>4</td>
    <td>AQA 7517 Specification</td>
  </tr>
  <tr>
    <td>4_1</td>
    <td>Fundamentals of programming</td>
  </tr>
  <tr>
    <td>4_1_1</td>
    <td>Programming</td>
  </tr>
  <tr>
    <td>4_1_1_1</td>
    <td>Data types</td>
  </tr>
  <tr>
    <td>4_1_1_1_1</td>
    <td>Understand the concept of a data type.</td>
  </tr>
  <tr>
    <td>4_1_1_1_2</td>
    <td>Understand and use the following appropriately:</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_1</td>
    <td>• integer</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_2</td>
    <td>• real/float</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_3</td>
    <td>• Boolean</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_4</td>
    <td>• character</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_5</td>
    <td>• string</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_6</td>
    <td>• date/time</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_7</td>
    <td>• records (or equivalent)</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_8</td>
    <td>• arrays (or equivalent).</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_9</td>
    <td>•+  pointer/reference</td>
  </tr>
  <tr>
    <td>4_1_1_1_2_10</td>
    <td>x+ Variables declared as a pointer or reference data type are used as stores for memory addresses of objects created at runtime; ie dynamically. Not all languages support explicit pointer types; but students should have an opportunity to understand this data type.</td>
  </tr>
  <tr>
    <td>4_1_1_1_3</td>
    <td>Define and use user-defined data types based on language-defined (built-in) data types.</td>
  </tr>
  <tr>
    <td>4_1_1_2</td>
    <td>Programming concepts</td>
  </tr>
  <tr>
    <td>4_1_1_2_1</td>
    <td>Use; understand and know how the following statement types can be combined in programs:</td>
  </tr>
  <tr>
    <td>4_1_1_2_1_1</td>
    <td>• variable declaration</td>
  </tr>
  <tr>
    <td>4_1_1_2_1_2</td>
    <td>• constant declaration</td>
  </tr>
  <tr>
    <td>4_1_1_2_1_3</td>
    <td>• assignment</td>
  </tr>
  <tr>
    <td>4_1_1_2_1_4</td>
    <td>• iteration</td>
  </tr>
  <tr>
    <td>4_1_1_2_1_5</td>
    <td>• selection</td>
  </tr>
  <tr>
    <td>4_1_1_2_1_6</td>
    <td>• subroutine (procedure/function).</td>
  </tr>
  <tr>
    <td>4_1_1_2_1_7</td>
    <td>x The three combining principles (sequence;iteration/repetition and selection/choice) are basic to all imperative programming languages.</td>
  </tr>
  <tr>
    <td>4_1_1_2_2</td>
    <td>Use iteration:</td>
  </tr>
  <tr>
    <td>4_1_1_2_2_1</td>
    <td>•definite iteration</td>
  </tr>
  <tr>
    <td>4_1_1_2_2_2</td>
    <td>•indefinite iteration</td>
  </tr>
  <tr>
    <td>4_1_1_2_2_3</td>
    <td>•indefinite condition(s) at the start or the end of the iterative structure</td>
  </tr>
  <tr>
    <td>4_1_1_2_2_4</td>
    <td>x theoretical understanding of condition(s) at either end of an iterative structure is required; regardless of whether they are supported by the language being used.</td>
  </tr>
  <tr>
    <td>4_1_1_2_3</td>
    <td>Use nested selection and nested iteration structures.</td>
  </tr>
  <tr>
    <td>4_1_1_2_4</td>
    <td>Use meaningful identifier names and know why it is important to use them.
</td>
  </tr>
  <tr>
    <td>4_1_1_3</td>
    <td>Arithmetic operations in a programming language</td>
  </tr>
  <tr>
    <td>4_1_1_3_1</td>
    <td>Be familiar with and be able to use:</td>
  </tr>
  <tr>
    <td>4_1_1_3_1_1</td>
    <td>• addition</td>
  </tr>
  <tr>
    <td>4_1_1_3_1_2</td>
    <td>• subtraction</td>
  </tr>
  <tr>
    <td>4_1_1_3_1_3</td>
    <td>• multiplication</td>
  </tr>
  <tr>
    <td>4_1_1_3_1_4</td>
    <td>• real/float division</td>
  </tr>
  <tr>
    <td>4_1_1_3_1_5</td>
    <td>• integer division; including remainders</td>
  </tr>
  <tr>
    <td>4_1_1_3_1_6</td>
    <td>• exponentiation</td>
  </tr>
  <tr>
    <td>4_1_1_3_1_7</td>
    <td>• rounding</td>
  </tr>
  <tr>
    <td>4_1_1_3_1_8</td>
    <td>• truncation.</td>
  </tr>
  <tr>
    <td>4_1_1_4</td>
    <td>Relational operations in a programming language</td>
  </tr>
  <tr>
    <td>4_1_1_4_1</td>
    <td>Be familiar with and be able to use:</td>
  </tr>
  <tr>
    <td>4_1_1_4_1_1</td>
    <td>• equal to</td>
  </tr>
  <tr>
    <td>4_1_1_4_1_2</td>
    <td>• not equal to</td>
  </tr>
  <tr>
    <td>4_1_1_4_1_3</td>
    <td>• less than</td>
  </tr>
  <tr>
    <td>4_1_1_4_1_4</td>
    <td>• greater than</td>
  </tr>
  <tr>
    <td>4_1_1_4_1_5</td>
    <td>• less than or equal to</td>
  </tr>
  <tr>
    <td>4_1_1_4_1_6</td>
    <td>• greater than or equal to.</td>
  </tr>
  <tr>
    <td>4_1_1_5</td>
    <td>Boolean operations in a programming language</td>
  </tr>
  <tr>
    <td>4_1_1_5_1</td>
    <td>Be familiar with and be able to use:</td>
  </tr>
  <tr>
    <td>4_1_1_5_1_1</td>
    <td>• NOT</td>
  </tr>
  <tr>
    <td>4_1_1_5_1_2</td>
    <td>• AND</td>
  </tr>
  <tr>
    <td>4_1_1_5_1_3</td>
    <td>• OR</td>
  </tr>
  <tr>
    <td>4_1_1_5_1_4</td>
    <td>• XOR.</td>
  </tr>
  <tr>
    <td>4_1_1_6</td>
    <td>Constants and variables in a programming language</td>
  </tr>
  <tr>
    <td>4_1_1_6_1</td>
    <td>Be able to explain the differences between a variable and a constant.</td>
  </tr>
  <tr>
    <td>4_1_1_6_2</td>
    <td>Be able to explain the advantages of using named constants.
</td>
  </tr>
  <tr>
    <td>4_1_1_7</td>
    <td>String-handling operations in a programming language</td>
  </tr>
  <tr>
    <td>4_1_1_7_1</td>
    <td>Be familiar with and be able to use:</td>
  </tr>
  <tr>
    <td>4_1_1_7_1_1</td>
    <td>• length</td>
  </tr>
  <tr>
    <td>4_1_1_7_1_2</td>
    <td>• position</td>
  </tr>
  <tr>
    <td>4_1_1_7_1_3</td>
    <td>• substring</td>
  </tr>
  <tr>
    <td>4_1_1_7_1_4</td>
    <td>• concatenation</td>
  </tr>
  <tr>
    <td>4_1_1_7_1_5</td>
    <td>• character -> character code</td>
  </tr>
  <tr>
    <td>4_1_1_7_1_6</td>
    <td>• character code -> character</td>
  </tr>
  <tr>
    <td>4_1_1_7_1_7</td>
    <td>• string conversion operations.</td>
  </tr>
  <tr>
    <td>4_1_1_7_1_8</td>
    <td>x Expected string conversion operations: string to integer; string to float; integer to string; float to string; date/time to string; string to date/time.</td>
  </tr>
  <tr>
    <td>4_1_1_8</td>
    <td>Random number generation in a programming language</td>
  </tr>
  <tr>
    <td>4_1_1_8_1</td>
    <td>Be familiar with; and be able to use; random number generation.</td>
  </tr>
  <tr>
    <td>4_1_1_9</td>
    <td>Exception handling</td>
  </tr>
  <tr>
    <td>4_1_1_9_1</td>
    <td>Be familiar with the concept of exception handling.</td>
  </tr>
  <tr>
    <td>4_1_1_9_2</td>
    <td>Know how to use exception handling in a programming language with which students are familiar.</td>
  </tr>
  <tr>
    <td>4_1_1_10</td>
    <td>Subroutines (procedures/functions)</td>
  </tr>
  <tr>
    <td>4_1_1_10_1</td>
    <td>Be familiar with subroutines and their uses.</td>
  </tr>
  <tr>
    <td>4_1_1_10_2</td>
    <td>Know that a subroutine is a named ‘out of line’ block of code that may be executed (called) by simply writing its name in a program statement.</td>
  </tr>
  <tr>
    <td>4_1_1_10_3</td>
    <td>Be able to explain the advantages of using subroutines in programs</td>
  </tr>
  <tr>
    <td>4_1_1_11</td>
    <td>Parameters of subroutines</td>
  </tr>
  <tr>
    <td>4_1_1_11_1</td>
    <td>Be able to describe the use of parameters to pass data within programs.</td>
  </tr>
  <tr>
    <td>4_1_1_11_2</td>
    <td>Be able to use subroutines with interfaces.</td>
  </tr>
  <tr>
    <td>4_1_1_12</td>
    <td>Returning a value/values from a subroutine</td>
  </tr>
  <tr>
    <td>4_1_1_12_1</td>
    <td>Be able to use subroutines that return values to the calling routine.</td>
  </tr>
  <tr>
    <td>4_1_1_13</td>
    <td>Local variables in subroutines</td>
  </tr>
  <tr>
    <td>4_1_1_13_1</td>
    <td>Know that subroutines may declare their own variables; called local variables; and that local variables:</td>
  </tr>
  <tr>
    <td>4_1_1_13_1_1</td>
    <td>• exist only while the subroutine is executing</td>
  </tr>
  <tr>
    <td>4_1_1_13_1_2</td>
    <td>• are accessible only within the subroutine.</td>
  </tr>
  <tr>
    <td>4_1_1_13_2</td>
    <td>Be able to use local variables and explain why it is good practice to do so.</td>
  </tr>
  <tr>
    <td>4_1_1_14</td>
    <td>Global variables in a programming language</td>
  </tr>
  <tr>
    <td>4_1_1_14_1</td>
    <td>Be able to contrast local variables with global variables</td>
  </tr>
  <tr>
    <td>4_1_1_15</td>
    <td>Role of stack frames in subroutine calls</td>
  </tr>
  <tr>
    <td>4_1_1_15_1</td>
    <td>Be able to explain how a stack frame is used with subroutine calls to store:</td>
  </tr>
  <tr>
    <td>4_1_1_15_1_1</td>
    <td>• return addresses</td>
  </tr>
  <tr>
    <td>4_1_1_15_1_2</td>
    <td>• parameters</td>
  </tr>
  <tr>
    <td>4_1_1_15_1_3</td>
    <td>• local variables.</td>
  </tr>
  <tr>
    <td>4_1_1_16</td>
    <td>Recursive techniques</td>
  </tr>
  <tr>
    <td>4_1_1_16_1</td>
    <td>Be familiar with the use of recursive techniques in programming languages (general and base cases and the mechanism for implementation).</td>
  </tr>
  <tr>
    <td>4_1_1_16_2</td>
    <td>Be able to solve simple problems using recursion.</td>
  </tr>
  <tr>
    <td>4_1_2</td>
    <td>Programming paradigms</td>
  </tr>
  <tr>
    <td>4_1_2_1</td>
    <td>Programming paradigms</td>
  </tr>
  <tr>
    <td>4_1_2_1_1</td>
    <td>Understand the characteristics of the procedural- and object-oriented programming paradigms; and have experience of programming in each.</td>
  </tr>
  <tr>
    <td>3_1_2</td>
    <td>Procedural-oriented programming</td>
  </tr>
  <tr>
    <td>3_1_2_1</td>
    <td>Structured programming</td>
  </tr>
  <tr>
    <td>3_1_2_1_1</td>
    <td>Understand the structured approach to program design and construction.</td>
  </tr>
  <tr>
    <td>3_1_2_1_2</td>
    <td>Be able to construct and use hierarchy charts when designing programs.</td>
  </tr>
  <tr>
    <td>3_1_2_1_3</td>
    <td>Be able to explain the advantages of the structured approach.</td>
  </tr>
  <tr>
    <td>4_1_2_2</td>
    <td>Procedural-oriented programming</td>
  </tr>
  <tr>
    <td>4_1_2_2_1</td>
    <td>Understand the structured approach to program design and construction.</td>
  </tr>
  <tr>
    <td>4_1_2_2_2</td>
    <td>Be able to construct and use hierarchy charts when designing programs.</td>
  </tr>
  <tr>
    <td>4_1_2_2_3</td>
    <td>Be able to explain the advantages of the structured approach.</td>
  </tr>
  <tr>
    <td>4_1_2_3</td>
    <td>Object-oriented programming</td>
  </tr>
  <tr>
    <td>4_1_2_3_1</td>
    <td>Be familiar with the concepts of:</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_1</td>
    <td>• class</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_2</td>
    <td>• object</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_3</td>
    <td>• instantiation</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_4</td>
    <td>• encapsulation</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_5</td>
    <td>• inheritance</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_6</td>
    <td>• aggregation</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_7</td>
    <td>• composition</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_8</td>
    <td>• polymorphism</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_9</td>
    <td>• overriding.</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_10</td>
    <td>x+ Students should know that a class defines methods and property/ attribute fields that capture the common behaviours and characteristics of objects • </td>
  </tr>
  <tr>
    <td>4_1_2_3_1_11</td>
    <td>x+ Students should know that objects based on a class are created using a constructor; implicit or explicit; and a reference to the object assigned to a reference variable of the class type</td>
  </tr>
  <tr>
    <td>4_1_2_3_1_12</td>
    <td>x+ Students should know that in the Unified Modelling Language (UML) composition is represented by a black diamond line and aggregation by a white diamond line.</td>
  </tr>
  <tr>
    <td>4_1_2_3_2</td>
    <td>Know why the object-oriented paradigm is used.</td>
  </tr>
  <tr>
    <td>4_1_2_3_3</td>
    <td>Be aware of the following object-oriented design principles:</td>
  </tr>
  <tr>
    <td>4_1_2_3_3_1</td>
    <td>• encapsulate what varies</td>
  </tr>
  <tr>
    <td>4_1_2_3_3_2</td>
    <td>• favour composition over inheritance</td>
  </tr>
  <tr>
    <td>4_1_2_3_3_3</td>
    <td>• program to interfaces; not implementation.</td>
  </tr>
  <tr>
    <td>4_1_2_3_3_4</td>
    <td>x+ Students would benefit from practical experience of programming to an interface; but will not be explicitly tested on programming to interfaces or be  equired to program to interfaces in any practical exam.</td>
  </tr>
  <tr>
    <td>4_1_2_3_4</td>
    <td>Be able to write object-oriented programs.</td>
  </tr>
  <tr>
    <td>4_1_2_3_4_1</td>
    <td>x+ Practical experience of coding for user-defined classes involving: abstract; virtual and static methods; inheritance; aggregation; polymorphism;  public; private and protected specifiers.</td>
  </tr>
  <tr>
    <td>4_1_2_3_5</td>
    <td>Be able to draw and interpret class diagrams</td>
  </tr>
  <tr>
    <td>4_1_2_3_5_1</td>
    <td>x+ Class diagrams involving single inheritance; composition (black diamond line); aggregation (white diamond line); public (+); private (-) and protected (#) specifiers</td>
  </tr>
  <tr>
    <td>4_2</td>
    <td>Fundamentals of data structures</td>
  </tr>
  <tr>
    <td>4_2_1</td>
    <td>Data structures and abstract data types</td>
  </tr>
  <tr>
    <td>4_2_1_1</td>
    <td>Data structures</td>
  </tr>
  <tr>
    <td>4_2_1_1_1</td>
    <td>Be familiar with the concept of data structures. It may be helpful to set the concept of a data</td>
  </tr>
  <tr>
    <td>4_2_1_1_1_1</td>
    <td>x It may be helpful to set the concept of a data structure in various contexts that students may already be familiar with. It may also be helpful to suggest/demonstrate how data structures could be used in a practical setting.</td>
  </tr>
  <tr>
    <td>4_2_1_2</td>
    <td>Single- and multi-dimensional arrays (or equivalent)</td>
  </tr>
  <tr>
    <td>4_2_1_2_1</td>
    <td>Use arrays (or equivalent) in the design of solutions to simple problems.</td>
  </tr>
  <tr>
    <td>4_2_1_2_1_1</td>
    <td>x A one-dimensional array is a useful way of representing a vector. A two-dimensional array is a useful way of representing a matrix. More generally; an n-dimensional array is a set of elements with the same data type that are indexed by a tuple of n integers; where a tuple is an ordered list of elements.</td>
  </tr>
  <tr>
    <td>4_2_1_3</td>
    <td>Fields; records and files</td>
  </tr>
  <tr>
    <td>4_2_1_3_1</td>
    <td>Be able to read/write from/to a text file.</td>
  </tr>
  <tr>
    <td>4_2_1_3_2</td>
    <td>Be able to read/write data from/to a binary (nontext) file.</td>
  </tr>
  <tr>
    <td>4_2_1_4</td>
    <td>Abstract data types/data structures</td>
  </tr>
  <tr>
    <td>4_2_1_4_1</td>
    <td>Be familiar with the concept and uses of a:</td>
  </tr>
  <tr>
    <td>4_2_1_4_1_1</td>
    <td>• queue</td>
  </tr>
  <tr>
    <td>4_2_1_4_1_2</td>
    <td>• stack</td>
  </tr>
  <tr>
    <td>4_2_1_4_1_3</td>
    <td>• graph</td>
  </tr>
  <tr>
    <td>4_2_1_4_1_4</td>
    <td>• tree</td>
  </tr>
  <tr>
    <td>4_2_1_4_1_5</td>
    <td>• hash table</td>
  </tr>
  <tr>
    <td>4_2_1_4_1_6</td>
    <td>• dictionary</td>
  </tr>
  <tr>
    <td>4_2_1_4_1_7</td>
    <td>• vector.</td>
  </tr>
  <tr>
    <td>4_2_1_4_1_8</td>
    <td>x+ Be able to use these abstract data types and their equivalent data structures in simple contexts.</td>
  </tr>
  <tr>
    <td>4_2_1_4_1_9</td>
    <td>x+ Students should also be familiar with methods for representing them when a programming language does not support these structures as built-in types.</td>
  </tr>
  <tr>
    <td>4_2_1_4_2</td>
    <td>Be able to distinguish between static and dynamic structures and compare their uses; as well as explaining the advantages and disadvantages of each.</td>
  </tr>
  <tr>
    <td>4_2_1_4_3</td>
    <td>Describe the creation and maintenance of data within:</td>
  </tr>
  <tr>
    <td>4_2_1_4_3_1</td>
    <td>• queues (linear; circular; priority)</td>
  </tr>
  <tr>
    <td>4_2_1_4_3_2</td>
    <td>• stacks</td>
  </tr>
  <tr>
    <td>4_2_1_4_3_3</td>
    <td>• hash tables</td>
  </tr>
  <tr>
    <td>4_2_2</td>
    <td>Queues</td>
  </tr>
  <tr>
    <td>4_2_2_1</td>
    <td>Queues</td>
  </tr>
  <tr>
    <td>4_2_2_1_1</td>
    <td>Be able to describe and apply the following to linear queues; circular queues and priority queues:</td>
  </tr>
  <tr>
    <td>4_2_2_1_1_1</td>
    <td>• add an item</td>
  </tr>
  <tr>
    <td>4_2_2_1_1_2</td>
    <td>• remove an item</td>
  </tr>
  <tr>
    <td>4_2_2_1_1_3</td>
    <td>• test for an empty queue</td>
  </tr>
  <tr>
    <td>4_2_2_1_1_4</td>
    <td>• test for a full queue.</td>
  </tr>
  <tr>
    <td>4_2_3</td>
    <td>Stacks</td>
  </tr>
  <tr>
    <td>4_2_3_1</td>
    <td>Stacks</td>
  </tr>
  <tr>
    <td>4_2_3_1_1</td>
    <td>Be able to describe and apply the following operations:</td>
  </tr>
  <tr>
    <td>4_2_3_1_1_1</td>
    <td>• push</td>
  </tr>
  <tr>
    <td>4_2_3_1_1_2</td>
    <td>• pop</td>
  </tr>
  <tr>
    <td>4_2_3_1_1_3</td>
    <td>• peek or top</td>
  </tr>
  <tr>
    <td>4_2_3_1_1_4</td>
    <td>• test for empty stack</td>
  </tr>
  <tr>
    <td>4_2_3_1_1_5</td>
    <td>• test for stack full.</td>
  </tr>
  <tr>
    <td>4_2_3_1_1_6</td>
    <td>x+ Peek or top returns the value of the top element without removing it.</td>
  </tr>
  <tr>
    <td>4_2_4</td>
    <td>Graphs</td>
  </tr>
  <tr>
    <td>4_2_4_1</td>
    <td>Graphs</td>
  </tr>
  <tr>
    <td>4_2_4_1_1</td>
    <td>Be aware of a graph as a data structure used to represent more complex relationships.</td>
  </tr>
  <tr>
    <td>4_2_4_1_2</td>
    <td>Be familiar with typical uses for graphs.</td>
  </tr>
  <tr>
    <td>4_2_4_1_3</td>
    <td>Be able to explain the terms:</td>
  </tr>
  <tr>
    <td>4_2_4_1_3_1</td>
    <td>• graph</td>
  </tr>
  <tr>
    <td>4_2_4_1_3_2</td>
    <td>• weighted graph</td>
  </tr>
  <tr>
    <td>4_2_4_1_3_3</td>
    <td>• vertex/node</td>
  </tr>
  <tr>
    <td>4_2_4_1_3_4</td>
    <td>• edge/arc</td>
  </tr>
  <tr>
    <td>4_2_4_1_3_5</td>
    <td>• undirected graph</td>
  </tr>
  <tr>
    <td>4_2_4_1_3_6</td>
    <td>• directed graph.</td>
  </tr>
  <tr>
    <td>4_2_4_1_4</td>
    <td>Know how an adjacency matrix and an adjacency list may be used to represent a graph.</td>
  </tr>
  <tr>
    <td>4_2_4_1_5</td>
    <td>Be able to compare the use of adjacency matrices and adjacency lists</td>
  </tr>
  <tr>
    <td>4_2_5</td>
    <td>Trees</td>
  </tr>
  <tr>
    <td>4_2_5_1</td>
    <td>Trees (including binary trees)</td>
  </tr>
  <tr>
    <td>4_2_5_1_1</td>
    <td>Know that a tree is a connected; undirected graph with no cycles.</td>
  </tr>
  <tr>
    <td>4_2_5_1_1_1</td>
    <td>x+ Note that a tree does not have to have a root.</td>
  </tr>
  <tr>
    <td>4_2_5_1_2</td>
    <td>Know that a rooted tree is a tree in which one vertex has been designated as the root. A rooted tree has parent-child relationships between nodes. The root is the only node with no parent and all other nodes are descendants of the root.</td>
  </tr>
  <tr>
    <td>4_2_5_1_3</td>
    <td>Know that a binary tree is a rooted tree in which each node has at most two children.</td>
  </tr>
  <tr>
    <td>4_2_5_1_4</td>
    <td>Be familiar with typical uses for rooted trees.</td>
  </tr>
  <tr>
    <td>4_2_6</td>
    <td>Hash tables</td>
  </tr>
  <tr>
    <td>4_2_6_1</td>
    <td>Hash tables</td>
  </tr>
  <tr>
    <td>4_2_6_1_1</td>
    <td>Be familiar with the concept of a hash table and its uses.</td>
  </tr>
  <tr>
    <td>4_2_6_1_1_1</td>
    <td>x+ A hash table is a data structure that creates a mapping between keys and values.</td>
  </tr>
  <tr>
    <td>4_2_6_1_2</td>
    <td>Be able to apply simple hashing algorithms.</td>
  </tr>
  <tr>
    <td>4_2_6_1_3</td>
    <td>Know what is meant by a collision and how collisions are handled using rehashing.</td>
  </tr>
  <tr>
    <td>4_2_6_1_3_1</td>
    <td>x+ A collision occurs when two key values compute the same hash.</td>
  </tr>
  <tr>
    <td>4_2_7</td>
    <td>Dictionaries</td>
  </tr>
  <tr>
    <td>4_2_7_1</td>
    <td>Dictionaries</td>
  </tr>
  <tr>
    <td>4_2_7_1_1</td>
    <td>Be familiar with the concept of a dictionary.</td>
  </tr>
  <tr>
    <td>4_2_7_1_1_1</td>
    <td>x+ A collection of key-value pairs in which the value is accessed via the associated key.</td>
  </tr>
  <tr>
    <td>4_2_7_1_2</td>
    <td>Be familiar with simple applications of dictionaries; for example information retrieval; and have experience of using a dictionary data structure in a programming language.</td>
  </tr>
  <tr>
    <td>4_2_7_1_2_1</td>
    <td>x+ Information retrieval: For example; the document &#x27;The green; green grass grows&#x27; would be represented by the dictionary: {‘grass’ : 1; ‘green’ : 2; ‘grows’ : 1; ‘the’ : 1} ignoring letter case.</td>
  </tr>
  <tr>
    <td>4_2_8</td>
    <td>Vectors</td>
  </tr>
  <tr>
    <td>4_2_8_1</td>
    <td>Vectors</td>
  </tr>
  <tr>
    <td>4_2_8_1_1</td>
    <td>Be familiar with the concept of a vector and the following notations for specifying a vector:</td>
  </tr>
  <tr>
    <td>4_2_8_1_1_1</td>
    <td>• [2.0; 3.14159; -1.0; 2.718281828]</td>
  </tr>
  <tr>
    <td>4_2_8_1_1_2</td>
    <td>• 4-vector over R written as R^4</td>
  </tr>
  <tr>
    <td>4_2_8_1_1_3</td>
    <td>• function interpretation where 0 ¦? 2.0; 1 ¦? 3.14159; 2 ¦? -1.0; 3 ¦? 2.718281828. (¦? means maps to)</td>
  </tr>
  <tr>
    <td>4_2_8_1_2</td>
    <td>That all the entries must be drawn from the same field; eg R.</td>
  </tr>
  <tr>
    <td>4_2_8_1_2_1</td>
    <td>x+ A vector can be represented as a list of numbers; as a function and as a way of representing a geometric point in space.</td>
  </tr>
  <tr>
    <td>4_2_8_1_2_2</td>
    <td>x+ A dictionary is a useful way of representing a vector if a vector is viewed as a function.</td>
  </tr>
  <tr>
    <td>4_2_8_1_2_3</td>
    <td>x+ f : S ? ? the set S = {0;1;2;3} and the co-domain; ?; the set of Reals</td>
  </tr>
  <tr>
    <td>4_2_8_1_2_4</td>
    <td>x+ For example; in Python the 4-vector example could be represented as a dictionary as follows: {0:2.0; 1:3.14159; 2:-1.0; 3:2.718281828}</td>
  </tr>
  <tr>
    <td>4_2_8_1_3</td>
    <td>Dictionary representation of a vector.</td>
  </tr>
  <tr>
    <td>4_2_8_1_4</td>
    <td>List representation of a vector.</td>
  </tr>
  <tr>
    <td>4_2_8_1_4_1</td>
    <td>x+ For example; in Python; a 2-vector over R would be written as [2.0;3.0].</td>
  </tr>
  <tr>
    <td>4_2_8_1_5</td>
    <td>1-D array representation of a vector</td>
  </tr>
  <tr>
    <td>4_2_8_1_5_1</td>
    <td>x+ For example in VB.Net; a 4-vector over R would be written as Dim example(3) As Single</td>
  </tr>
  <tr>
    <td>4_2_8_1_6</td>
    <td>Visualising a vector as an arrow.</td>
  </tr>
  <tr>
    <td>4_2_8_1_6_1</td>
    <td>x+ For example a 2-vector [2.0; 3.0] over R can be represented by an arrow with its tail at the origin and its head at (2.0; 3.0).</td>
  </tr>
  <tr>
    <td>4_2_8_1_7</td>
    <td>Vector addition and scalar-vector multiplication.</td>
  </tr>
  <tr>
    <td>4_2_8_1_7_1</td>
    <td>x+ Know that vector addition achieves translation and scalar-vector multiplication achieves scaling.</td>
  </tr>
  <tr>
    <td>4_2_8_1_8</td>
    <td>Convex combination of two vectors; u and v.</td>
  </tr>
  <tr>
    <td>4_2_8_1_8_1</td>
    <td>x+ Is an expression of the form Au + Bv where A;B &gt;=0 and A+B=1</td>
  </tr>
  <tr>
    <td>4_2_8_1_9</td>
    <td>Dot or scalar product of two vectors.</td>
  </tr>
  <tr>
    <td>4_2_8_1_9_1</td>
    <td>x+ The dot product of two vectors; u and v; u = [u1; ….; un ] and v = [v1; …..; vn ] is u ? v = u1v1 + u2v2 + …… + unvn</td>
  </tr>
  <tr>
    <td>4_2_8_1_10</td>
    <td>Applications of dot product.</td>
  </tr>
  <tr>
    <td>4_2_8_1_10_1</td>
    <td>x+ Finding the angle between two vectors.</td>
  </tr>
  <tr>
    <td>4_3</td>
    <td>Fundamentals of algorithms</td>
  </tr>
  <tr>
    <td>4_3_1</td>
    <td>Graph-traversal</td>
  </tr>
  <tr>
    <td>4_3_1_1</td>
    <td>Simple graph-traversal algorithms</td>
  </tr>
  <tr>
    <td>4_3_1_1_1</td>
    <td>Be able to trace breadth-first and depth-firstsearch algorithms and describe typical applications of both.</td>
  </tr>
  <tr>
    <td>4_3_1_1_1_1</td>
    <td>x+ Breadth-first: shortest path for an unweighted graph.</td>
  </tr>
  <tr>
    <td>4_3_2_1_1_2</td>
    <td>x+ Depth-first: Navigating a maze.</td>
  </tr>
  <tr>
    <td>4_3_2</td>
    <td> Tree-traversal</td>
  </tr>
  <tr>
    <td>4_3_2_1</td>
    <td>Simple tree-traversal algorithms</td>
  </tr>
  <tr>
    <td>4_3_2_1_1</td>
    <td>Be able to trace the tree-traversal algorithms:</td>
  </tr>
  <tr>
    <td>4_3_2_1_1_1</td>
    <td>• pre-order</td>
  </tr>
  <tr>
    <td>4_3_2_1_1_2</td>
    <td>• post-order</td>
  </tr>
  <tr>
    <td>4_3_2_1_1_3</td>
    <td>• in-order.</td>
  </tr>
  <tr>
    <td>4_3_2_1_2</td>
    <td>Be able to describe uses of tree-traversal algorithms.</td>
  </tr>
  <tr>
    <td>4_3_2_1_2_1</td>
    <td>x+ Pre-Order: copying a tree.</td>
  </tr>
  <tr>
    <td>4_3_2_1_2_2</td>
    <td>x+ In-Order: binary search tree; outputting the contents of a binary search tree in ascending order.</td>
  </tr>
  <tr>
    <td>4_3_2_1_2</td>
    <td>x+ Post-Order: Infix to RPN (Reverse Polish Notation) conversions; producing a postfix expression from an expression tree; emptying a tree.</td>
  </tr>
  <tr>
    <td>4_3_3</td>
    <td>Reverse Polish</td>
  </tr>
  <tr>
    <td>4_3_3_1</td>
    <td>Reverse Polish – infix transformations</td>
  </tr>
  <tr>
    <td>4_3_3_1_1</td>
    <td>Be able to convert simple expressions in infix form to Reverse Polish notation (RPN) form and ice versa. Be aware of why and where it is used.</td>
  </tr>
  <tr>
    <td>4_3_3_1_1_1</td>
    <td>x+ Eliminates need for brackets in subexpressions.</td>
  </tr>
  <tr>
    <td>4_3_3_1_1_2</td>
    <td>x+ Expressions in a form suitable for evaluation using a stack.</td>
  </tr>
  <tr>
    <td>4_3_3_1_1_3</td>
    <td>x+ Used in interpreters based on a stack for example Postscript and bytecode.</td>
  </tr>
  <tr>
    <td>4_3_4</td>
    <td>Searching algorithms</td>
  </tr>
  <tr>
    <td>4_3_4_1</td>
    <td>Linear search</td>
  </tr>
  <tr>
    <td>4_3_4_1_1</td>
    <td>Know and be able to trace and analyse thecomplexity of the linear search algorithm.
</td>
  </tr>
  <tr>
    <td>4_3_4_1_1_1</td>
    <td>x+ Time complexity is O(n).</td>
  </tr>
  <tr>
    <td>4_3_4_2</td>
    <td>Binary search</td>
  </tr>
  <tr>
    <td>4_3_4_2_1</td>
    <td>Know and be able to trace and analyse the time complexity of the binary search algorithm.</td>
  </tr>
  <tr>
    <td>4_3_4_2_1_1</td>
    <td>x+ Time complexity is O(log n).</td>
  </tr>
  <tr>
    <td>4_3_4_3</td>
    <td>Binary tree search</td>
  </tr>
  <tr>
    <td>4_3_4_3_1</td>
    <td>Be able to trace and analyse the time complexity of the binary tree search algorithm.</td>
  </tr>
  <tr>
    <td>4_3_4_3_1_1</td>
    <td>x+ Time complexity is O(log n).</td>
  </tr>
  <tr>
    <td>4_3_5</td>
    <td>Sorting algorithms</td>
  </tr>
  <tr>
    <td>4_3_5_1</td>
    <td>Bubble sort</td>
  </tr>
  <tr>
    <td>4_3_5_1_1</td>
    <td>Know and be able to trace and analyse the time complexity of the binary search algorithm.</td>
  </tr>
  <tr>
    <td>4_3_5_1_1_1</td>
    <td>x+ This is included as an example of a particularly inefficient sorting algorithm; time-wise. Time complexity is O(n2).</td>
  </tr>
  <tr>
    <td>4_3_5_2</td>
    <td>Merge sort</td>
  </tr>
  <tr>
    <td>4_3_5_2_1</td>
    <td>Be able to trace and analyse the time complexity of the binary tree search algorithm.</td>
  </tr>
  <tr>
    <td>4_3_5_2_2</td>
    <td>The &#x27;merge&#x27; sort is an example of &#x27;Divide and Conquer&#x27; approach to problem solving. Time complexity is O(nlog n).</td>
  </tr>
  <tr>
    <td>4_3_6</td>
    <td>Optimisation algorithms</td>
  </tr>
  <tr>
    <td>4_3_6_1</td>
    <td>Dijkstra’s shortest path algorithm</td>
  </tr>
  <tr>
    <td>4_3_6_1_1</td>
    <td>Understand and be able to trace Dijkstra’s shortest path algorithm.</td>
  </tr>
  <tr>
    <td>4_3_6_1_2</td>
    <td>Be aware of applications of shortest path algorithm.</td>
  </tr>
  <tr>
    <td>4_3_6_1_2_1</td>
    <td>x+ Students will not be expected to recall the steps in Dijkstra&#x27;s shortest path algorithm.</td>
  </tr>
  <tr>
    <td>3_3</td>
    <td>Systematic approach to problem solving</td>
  </tr>
  <tr>
    <td>3_3_1</td>
    <td>Aspects of software development</td>
  </tr>
  <tr>
    <td>3_3_1_1</td>
    <td>Analysis</td>
  </tr>
  <tr>
    <td>3_3_1_1_1</td>
    <td>Be aware that before a problem can be solved; it must be defined; the requirements of the system that solves the problem must be established and a data model created.</td>
  </tr>
  <tr>
    <td>3_3_1_1_1_1</td>
    <td>x Students should have experience of using  abstraction to model aspects of the external world in a program.</td>
  </tr>
  <tr>
    <td>3_3_1_2</td>
    <td>Design</td>
  </tr>
  <tr>
    <td>3_3_1_2_1</td>
    <td>Be aware that before constructing a solution; the solution should be designed and specificed; for example planning data structures for the data model; designing algorithms; designing an appropriate modular structure for the solution and designing the human user interface.</td>
  </tr>
  <tr>
    <td>3_3_1_2_1_1</td>
    <td>x Students should have sufficient experience of successfully structuring programs into modular parts with clear documented interfaces to enable them to design appropriate modular structures for solutions.</td>
  </tr>
  <tr>
    <td>3_3_1_3</td>
    <td>Implementation</td>
  </tr>
  <tr>
    <td>3_3_1_3_1</td>
    <td>Be aware that the models and algorithms need to be implemented in the form of data structures and code (instructions) that a computer can understand.</td>
  </tr>
  <tr>
    <td>3_3_1_3_1_1</td>
    <td>x Students should have sufficient practice of writing; debugging and testing programs to enable them to develop the skills to articulate how programs work; arguing for their correctness and efficiency using logical reasoning; test data and user feedback.</td>
  </tr>
  <tr>
    <td>3_3_1_4</td>
    <td>Testing</td>
  </tr>
  <tr>
    <td>3_3_1_4_1</td>
    <td>Be aware that the implementation must be tested for the presence of errors; using selected test data covering normal (typical); boundary and erroneous data.</td>
  </tr>
  <tr>
    <td>3_3_1_4_1_1</td>
    <td>x Students should have practical experience of designing and applying test data; normal; boundary and erroneous to the testing of programs so that they are familiar with these test data types and the purpose of testing.</td>
  </tr>
  <tr>
    <td>3_3_1_5</td>
    <td>Evaluation</td>
  </tr>
  <tr>
    <td>3_3_1_5_1</td>
    <td>Know the criteria for evaluating a computer system.</td>
  </tr>
  <tr>
    <td>4_4</td>
    <td>Theory of computation</td>
  </tr>
  <tr>
    <td>4_4_1</td>
    <td>Abstraction and automation</td>
  </tr>
  <tr>
    <td>4_4_1_1</td>
    <td>Problem-solving</td>
  </tr>
  <tr>
    <td>4_4_1_1_1</td>
    <td>Be able to develop solutions to simple logic problems.</td>
  </tr>
  <tr>
    <td>4_4_1_1_2</td>
    <td>Be able to check solutions to simple logic problems.</td>
  </tr>
  <tr>
    <td>4_4_1_2</td>
    <td>Following and writing algorithms</td>
  </tr>
  <tr>
    <td>4_4_1_2_1</td>
    <td>Understand the term algorithm.</td>
  </tr>
  <tr>
    <td>4_4_1_2_1_1</td>
    <td>x A sequence of steps that can be followed to complete a task and that always terminates.</td>
  </tr>
  <tr>
    <td>4_4_1_2_2</td>
    <td>Be able to express the solution to a simple problem as an algorithm using pseudo-code; with the standard constructs:</td>
  </tr>
  <tr>
    <td>4_4_1_2_2_1</td>
    <td>• sequence</td>
  </tr>
  <tr>
    <td>4_4_1_2_2_2</td>
    <td>• assignment</td>
  </tr>
  <tr>
    <td>4_4_1_2_2_3</td>
    <td>• selection</td>
  </tr>
  <tr>
    <td>4_4_1_2_2_4</td>
    <td>• iteration.</td>
  </tr>
  <tr>
    <td>4_4_1_2_3</td>
    <td>Be able to hand-trace algorithms.</td>
  </tr>
  <tr>
    <td>4_4_1_2_4</td>
    <td>Be able to convert an algorithm from pseudocode into high level language program code</td>
  </tr>
  <tr>
    <td>4_4_1_2_5</td>
    <td>Be able to articulate how a program works; arguing for its correctness and its efficiency using logical reasoning; test data and user feedback.</td>
  </tr>
  <tr>
    <td>4_4_1_3</td>
    <td>Abstraction</td>
  </tr>
  <tr>
    <td>4_4_1_3_1</td>
    <td>Be familiar with the concept of abstraction as used in computations and know that:</td>
  </tr>
  <tr>
    <td>4_4_1_3_1_1</td>
    <td>• representational abstraction is a representation arrived at by removing unnecessary  details</td>
  </tr>
  <tr>
    <td>4_4_1_3_1_2</td>
    <td>• abstraction by generalisation or categorisation is a grouping by common characteristics to arrive at a hierarchical relationship of the &#x27;is a kind of&#x27; type.</td>
  </tr>
  <tr>
    <td>4_4_1_4</td>
    <td>Information hiding</td>
  </tr>
  <tr>
    <td>4_4_1_4_1</td>
    <td>Be familiar with the process of hiding all details of an object that do not contribute to its essential characteristics.</td>
  </tr>
  <tr>
    <td>4_4_1_5</td>
    <td>Procedural abstraction</td>
  </tr>
  <tr>
    <td>4_4_1_5_1</td>
    <td>Know that procedural abstraction represents a computational method.</td>
  </tr>
  <tr>
    <td>4_4_1_5_1_1</td>
    <td>x The result of abstracting away the actual values used in any particular computation is a computational pattern or computational method - a procedure.</td>
  </tr>
  <tr>
    <td>4_4_1_6</td>
    <td>Functional abstraction</td>
  </tr>
  <tr>
    <td>4_4_1_6_1</td>
    <td>Know that for functional abstraction the particular computation method is hidden.</td>
  </tr>
  <tr>
    <td>4_4_1_6_1_1</td>
    <td>x The result of a procedural abstraction is a procedure; not a function. To get a function requires yet another abstraction; which disregards the particular computation method. This is functional abstraction.</td>
  </tr>
  <tr>
    <td>4_4_1_7</td>
    <td>Data abstraction</td>
  </tr>
  <tr>
    <td>4_4_1_7_1</td>
    <td>Know that details of how data are actually represented are hidden; allowing new kinds of data objects to be constructed from previously defined types of data objects.</td>
  </tr>
  <tr>
    <td>4_4_1_7_1_1</td>
    <td>x Data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed. For example; a stack could be implemented as an array and a pointer for top of stack.</td>
  </tr>
  <tr>
    <td>4_4_1_8</td>
    <td>Problem abstraction/reduction</td>
  </tr>
  <tr>
    <td>4_4_1_8_1</td>
    <td>Know that details are removed until the problem is represented in a way that is possible to solve because the problem reduces to one that has already been solved.</td>
  </tr>
  <tr>
    <td>4_4_1_9</td>
    <td>Decomposition</td>
  </tr>
  <tr>
    <td>4_4_1_9_1</td>
    <td>Know that procedural decomposition means breaking a problem into a number of subproblems; so that each sub-problem accomplishes an identifiable task; which might itself be further subdivided.</td>
  </tr>
  <tr>
    <td>4_4_1_10</td>
    <td>Composition</td>
  </tr>
  <tr>
    <td>4_4_1_10_1</td>
    <td>Know how to build a composition abstraction by combining procedures to form compound procedures.</td>
  </tr>
  <tr>
    <td>4_4_1_10_2</td>
    <td>Know how to build data abstractions by combining data objects to form compound data; for example tree data structure.</td>
  </tr>
  <tr>
    <td>4_4_1_11</td>
    <td>Automation</td>
  </tr>
  <tr>
    <td>4_4_1_11_1</td>
    <td>Understand that automation requires putting models (abstraction of real world objects/phenomena) into action to solve problems. This is achieved by:</td>
  </tr>
  <tr>
    <td>4_4_1_11_1_1</td>
    <td>• creating algorithms</td>
  </tr>
  <tr>
    <td>4_4_1_11_1_2</td>
    <td>• implementing the algorithms in program code (instructions)</td>
  </tr>
  <tr>
    <td>4_4_1_11_1_3</td>
    <td>• implementing the models in data structures</td>
  </tr>
  <tr>
    <td>4_4_1_11_1_4</td>
    <td>• executing the code.</td>
  </tr>
  <tr>
    <td>4_4_1_11_1_5</td>
    <td>x Computer science is about building clean abstract models (abstractions) of messy; noisy; real world objects or phenomena. Computer scientists have to choose what to include in models and what to discard; to determine the minimum amount of detail necessary to model in order to solve a given problem to the required degree of accuracy.</td>
  </tr>
  <tr>
    <td>4_4_1_11_1_6</td>
    <td>x Computer science deals with putting the models into action to solve problems. This involves creating algorithms for performing actions on; and with; the data that has been modelled.</td>
  </tr>
  <tr>
    <td>3_4_2</td>
    <td>Finite state machines (FSMs)</td>
  </tr>
  <tr>
    <td>3_4_2_1</td>
    <td>Finite state machines (FSMs) without output</td>
  </tr>
  <tr>
    <td>3_4_2_1_1</td>
    <td>Be able to draw and interpret simple state transition diagrams and state transition tables for FSMs with no output.</td>
  </tr>
  <tr>
    <td>4_4_2_1</td>
    <td>Finite state machines (FSMs) with and without output</td>
  </tr>
  <tr>
    <td>4_4_2_1_1</td>
    <td>Be able to draw and interpret simple state transition diagrams and state transition tables for FSMs with no output and with output (Mealy machines only).</td>
  </tr>
  <tr>
    <td>4_4_2_2</td>
    <td>Maths for regular expressions</td>
  </tr>
  <tr>
    <td>4_4_2_2_1</td>
    <td>Be familiar with the concept of a set and the following notations for specifying a set: A = {1; 2; 3; 4; 5 } or set comprehension: A = {x | x ? ? ? x ? 1 } where A is the set consisting of those objects x such that x ? ? and x ? 1 is true.</td>
  </tr>
  <tr>
    <td>4_4_2_2_2</td>
    <td>Know that the empty set; {}; is the set with no elements.</td>
  </tr>
  <tr>
    <td>4_4_2_2_3</td>
    <td>Know that an alternative symbol for the empty set is Ø.</td>
  </tr>
  <tr>
    <td>4_4_2_2_3_1</td>
    <td>x+ A set is an unordered collection of values in which each value occurs at most once.</td>
  </tr>
  <tr>
    <td>4_4_2_2_3</td>
    <td>x+ Several languages support set construction.</td>
  </tr>
  <tr>
    <td>4_4_2_2_3</td>
    <td>x+ In Python; for example; use of curly braces constructs a set: {1; 2; 3 }. | means such that. x ? ? means that x is a member of the set ? consisting of the atural numbers; ie {0; 1; 2; 3; 4; … }.</td>
  </tr>
  <tr>
    <td>4_4_2_2_3</td>
    <td>x+ The symbol ? means AND.</td>
  </tr>
  <tr>
    <td>4_4_2_2_3</td>
    <td>x+ The term ? x &gt; = 1 means AND x is greater than or equal to 1.</td>
  </tr>
  <tr>
    <td>4_4_2_2_3</td>
    <td>x+ In Python; {2 ? x for x in {1; 2; 3 }} constructs {2; 4; 6 }. This is said to be a set comprehension over the set {1; 2; 3 } .</td>
  </tr>
  <tr>
    <td>4_4_2_2_4</td>
    <td>Be familiar with the compact representation of a set; for example; the set {0n1n | n ? 1}. This set contains all strings with an equal number of 0 s and 1s.</td>
  </tr>
  <tr>
    <td>4_4_2_2_4_1</td>
    <td>x+ For example; {0n1n | n ? 1} = {01; 0011; 000111; 00001111; … }</td>
  </tr>
  <tr>
    <td>4_4_2_2_5</td>
    <td>Be familiar with the concept of:</td>
  </tr>
  <tr>
    <td>4_4_2_2_5_1</td>
    <td>• finite sets</td>
  </tr>
  <tr>
    <td>4_4_2_2_5_2</td>
    <td>x+ A finite set is one whose elements can be counted off by natural numbers up to a particular number; for example as: 1st element; 2nd element; …; 20th (and final) element.</td>
  </tr>
  <tr>
    <td>4_4_2_2_5_3</td>
    <td>• infinite sets</td>
  </tr>
  <tr>
    <td>4_4_2_2_5_4</td>
    <td>x+ The set of natural numbers; ? and the set of real numbers; ? are examples of infinite sets.</td>
  </tr>
  <tr>
    <td>4_4_2_2_5_5</td>
    <td>• countably infinite sets</td>
  </tr>
  <tr>
    <td>4_4_2_2_5_6</td>
    <td>x+ A countably infinite set is one that can be counted off by the natural numbers.</td>
  </tr>
  <tr>
    <td>4_4_2_2_5_7</td>
    <td>x+ The set of real numbers is not countable. </td>
  </tr>
  <tr>
    <td>4_4_2_2_5_8</td>
    <td>• cardinality of a finite set</td>
  </tr>
  <tr>
    <td>4_4_2_2_5_9</td>
    <td>x+ The cardinality of a finite set is the number of elements in a set. </td>
  </tr>
  <tr>
    <td>4_4_2_2_5_10</td>
    <td>• Cartesian product of sets.</td>
  </tr>
  <tr>
    <td>4_4_2_2_5_11</td>
    <td>x+ Cartesian product of two sets; X and Y; written X x Y and read &#x27;X cross Y&#x27;; is the set of all ordered pairs (a; b) where a is a member of A and b is a member of B.</td>
  </tr>
  <tr>
    <td>4_4_2_2_6</td>
    <td>Be familiar with the meaning of the term:</td>
  </tr>
  <tr>
    <td>4_4_2_2_6_1</td>
    <td>• subset</td>
  </tr>
  <tr>
    <td>4_4_2_2_6_2</td>
    <td>x+ {0; 1 ; 2 } ? {0; 1; 2; 3 } where ? means subset of.? includes both ? and =; for example {0; 1; 2; 3 } ? {0; 1; 2; 3 } is also true; because {0; 1; 2; 3 } = {0; 1; 2; 3 }. </td>
  </tr>
  <tr>
    <td>4_4_2_2_6_3</td>
    <td>• proper subset</td>
  </tr>
  <tr>
    <td>4_4_2_2_6_4</td>
    <td>x+ {0; 1 ; 2 } ? ? where ? means proper subset of; that is ? contains everything in {0; 1; 2 } but there is at least one element in ? that is not in {0; 1; 2 }.</td>
  </tr>
  <tr>
    <td>4_4_2_2_6_5</td>
    <td>• countable set.</td>
  </tr>
  <tr>
    <td>4_4_2_2_6_6</td>
    <td>x+ A countable set is a set with the same cardinality (number of elements) as some subset of natural numbers.</td>
  </tr>
  <tr>
    <td>4_4_2_2_7</td>
    <td>Be familiar with the set operations:</td>
  </tr>
  <tr>
    <td>4_4_2_2_7_1</td>
    <td>• membership</td>
  </tr>
  <tr>
    <td>4_4_2_2_7_2</td>
    <td>• union</td>
  </tr>
  <tr>
    <td>4_4_2_2_7_3</td>
    <td>• intersection</td>
  </tr>
  <tr>
    <td>4_4_2_2_7_4</td>
    <td>• difference.</td>
  </tr>
  <tr>
    <td>4_4_2_2_7_5</td>
    <td>x+ The set difference A\B (or alternatively A-B) is defined by A\B = {x : x ¸ A and x . B}</td>
  </tr>
  <tr>
    <td>4_4_2_3</td>
    <td>Regular expressions</td>
  </tr>
  <tr>
    <td>4_4_2_3_1</td>
    <td>Know that a regular expression is simply a way of describing a set and that regular expressions allow particular types of languages to be described in a convenient shorthand notation.</td>
  </tr>
  <tr>
    <td>4_4_2_3_1_1</td>
    <td>For example; the regular expression a(a|b)* generates the set of strings {a; aa; ab; aaa; aab; aba; …}.</td>
  </tr>
  <tr>
    <td>4_4_2_3_2</td>
    <td>Be able to form and use simple regular expressions for string manipulation and matching.</td>
  </tr>
  <tr>
    <td>4_4_2_3_2_1</td>
    <td>x+ Students should be familiar with the metacharacters: * (0 or more repetitions); + (1 or more repetitions); ? (0 or 1 repetitions; ie optional);  | (alternation; ie or); • ( ) to group regular expressions.</td>
  </tr>
  <tr>
    <td>4_4_2_3_2_2</td>
    <td>x+ Any other metacharacters used in an exam question will be explained as part of the question.</td>
  </tr>
  <tr>
    <td>4_4_2_3_3</td>
    <td>Be able to describe the relationship between regular expressions and FSMs.</td>
  </tr>
  <tr>
    <td>4_4_2_3_3_1</td>
    <td>x+ Regular expressions and FSMs are equivalent ways of defining a regular language</td>
  </tr>
  <tr>
    <td>4_4_2_3_4</td>
    <td>Be able to write a regular expression to recognise the same language as a given FSM and vice versa.</td>
  </tr>
  <tr>
    <td>4_4_2_3_4_1</td>
    <td>x+ A student&#x27;s ability to write very simple regular expressions and FSMs will be assessed.</td>
  </tr>
  <tr>
    <td>4_4_2_4</td>
    <td>Regular language</td>
  </tr>
  <tr>
    <td>4_4_2_4_1</td>
    <td>Know that a language is called regular if it can be represented by a regular expression.</td>
  </tr>
  <tr>
    <td>4_4_2_4_1_1</td>
    <td>Also; a regular language is any language that a FSM will accept.</td>
  </tr>
  <tr>
    <td>4_4_3</td>
    <td>Context-free languages</td>
  </tr>
  <tr>
    <td>4_4_3_1</td>
    <td>Backus-Naur Form (BNF)/syntax diagrams</td>
  </tr>
  <tr>
    <td>4_4_3_1_1</td>
    <td>Be able to check language syntax by referring to BNF or syntax diagrams and formulate simple production rules.</td>
  </tr>
  <tr>
    <td>4_4_3_1_2</td>
    <td>Be able to explain why BNF can represent some languages that cannot be represented using regular expressions.</td>
  </tr>
  <tr>
    <td>4_4_4</td>
    <td>Classification of algorithms</td>
  </tr>
  <tr>
    <td>4_4_4_1</td>
    <td>Comparing algorithms</td>
  </tr>
  <tr>
    <td>4_4_4_1_1</td>
    <td>Understand that algorithms can be compared by expressing their complexity as a function relative to the size of the problem. Understand that the size of the problem is the key issue.</td>
  </tr>
  <tr>
    <td>4_4_4_1_2</td>
    <td>Understand that some algorithms are more efficient:</td>
  </tr>
  <tr>
    <td>4_4_4_1_2_1</td>
    <td>• time-wise than other algorithms</td>
  </tr>
  <tr>
    <td>4_4_4_1_2_2</td>
    <td>• space-wise than other algorithms.</td>
  </tr>
  <tr>
    <td>4_4_4_1_2_3</td>
    <td>x+ Efficiently implementing automated abstractions means designing data models and algorithms to run quickly while taking up the minimal amount of resources such as memory.</td>
  </tr>
  <tr>
    <td>4_4_4_2</td>
    <td>Maths for understanding Big-0 notation</td>
  </tr>
  <tr>
    <td>4_4_4_2_1</td>
    <td>Be familiar with the mathematical concept of a function as a mapping from one set of values; the domain; to another set of values; drawn from the co-domain; for example ? ? ?.</td>
  </tr>
  <tr>
    <td>4_4_4_2_2</td>
    <td>Be familiar with the concept of:</td>
  </tr>
  <tr>
    <td>4_4_4_2_2_1</td>
    <td>• a linear function; for example y = 2x</td>
  </tr>
  <tr>
    <td>4_4_4_2_2_2</td>
    <td>• a polynomial function; for example y = 2x^2</td>
  </tr>
  <tr>
    <td>4_4_4_2_2_3</td>
    <td>• an exponential function; for example y =2^x</td>
  </tr>
  <tr>
    <td>4_4_4_2_2_4</td>
    <td>• a logarithmic function; for example y = log10 x.</td>
  </tr>
  <tr>
    <td>4_4_4_2_3</td>
    <td>Be familiar with the notion of permutation of a set of objects or values; for example; the letters of a word and that the number of permutations of n distinct objects is n factorial (n!).</td>
  </tr>
  <tr>
    <td>4_4_4_2_3_1</td>
    <td>x+ n! is the product of all positive integers less than or equal to n.</td>
  </tr>
  <tr>
    <td>4_4_4_3</td>
    <td>Order of complexity</td>
  </tr>
  <tr>
    <td>4_4_4_3_1</td>
    <td>Be familiar with Big-O notation to express time complexity and be able to apply it to cases where the running time requirements of the algorithm grow in:</td>
  </tr>
  <tr>
    <td>4_4_4_3_1_1</td>
    <td>• constant time</td>
  </tr>
  <tr>
    <td>4_4_4_3_1_2</td>
    <td>• logarithmic time</td>
  </tr>
  <tr>
    <td>4_4_4_3_1_3</td>
    <td>• linear time</td>
  </tr>
  <tr>
    <td>4_4_4_3_1_4</td>
    <td>• polynomial time</td>
  </tr>
  <tr>
    <td>4_4_4_3_1_5</td>
    <td>• exponential time.</td>
  </tr>
  <tr>
    <td>4_4_4_3_2</td>
    <td>Be able to derive the time complexity of an algorithm.</td>
  </tr>
  <tr>
    <td>4_4_4_4</td>
    <td>Limits of computation</td>
  </tr>
  <tr>
    <td>4_4_4_4_1</td>
    <td>Be aware that algorithmic complexity and hardware impose limits on what can be computed.</td>
  </tr>
  <tr>
    <td>4_4_4_5</td>
    <td>Classification of algorithmic problems</td>
  </tr>
  <tr>
    <td>4_4_4_5_1</td>
    <td>Know that algorithms may be classified as being either:</td>
  </tr>
  <tr>
    <td>4_4_4_5_1_1</td>
    <td>• tractable - problems that have a polynomial (or less) time solution are called tractable problems.</td>
  </tr>
  <tr>
    <td>4_4_4_5_1_2</td>
    <td>• intractable - problems that have no polynomial (or less) time solution are called intractable problems.</td>
  </tr>
  <tr>
    <td>4_4_4_5_1_3</td>
    <td>x+ Heuristic methods are often used when tackling intractable problems.</td>
  </tr>
  <tr>
    <td>4_4_4_6</td>
    <td>Computable and non-computable problems</td>
  </tr>
  <tr>
    <td>4_4_4_6_1</td>
    <td>Be aware that some problems cannot be solved algorithmically.</td>
  </tr>
  <tr>
    <td>4_4_4_7</td>
    <td>Halting problem</td>
  </tr>
  <tr>
    <td>4_4_4_7_1</td>
    <td>Describe the Halting problem (but not prove it); that is the unsolvable problem of determining whether any program will eventually stop if given particular input.</td>
  </tr>
  <tr>
    <td>4_4_4_7_2</td>
    <td>Understand the significance of the Halting problem for computation. </td>
  </tr>
  <tr>
    <td>4_4_4_7_2_1</td>
    <td>x+ The Halting problem demonstrates that there are some problems that cannot be solved by a computer. </td>
  </tr>
  <tr>
    <td>4_4_5</td>
    <td>A model of computation</td>
  </tr>
  <tr>
    <td>4_4_5_1</td>
    <td>Turing machine</td>
  </tr>
  <tr>
    <td>4_4_5_1_1</td>
    <td>Be familiar with the structure and use of Turing machines that perform simple computations.</td>
  </tr>
  <tr>
    <td>4_4_5_1_2</td>
    <td>Know that a Turing machine can be viewed as a computer with a single fixed program; expressed using:</td>
  </tr>
  <tr>
    <td>4_4_5_1_2_1</td>
    <td>• a finite set of states in a state transition diagram</td>
  </tr>
  <tr>
    <td>4_4_5_1_2_2</td>
    <td>• a finite alphabet of symbols</td>
  </tr>
  <tr>
    <td>4_4_5_1_2_3</td>
    <td>• an infinite tape with marked-off squares</td>
  </tr>
  <tr>
    <td>4_4_5_1_2_4</td>
    <td>• a sensing read-write head that can travel along the tape; one square at a time.</td>
  </tr>
  <tr>
    <td>4_4_5_1_3</td>
    <td>One of the states is called a start state and states that have no outgoing transitions are called halting states.</td>
  </tr>
  <tr>
    <td>4_4_5_1_3_1</td>
    <td>x+ Exam questions will only be asked about Turing machines that have one tape that is infinite in one direction.</td>
  </tr>
  <tr>
    <td>4_4_5_1_4</td>
    <td>Understand the equivalence between a transition function and a state transition diagram.</td>
  </tr>
  <tr>
    <td>4_4_5_1_5</td>
    <td>Be able to:</td>
  </tr>
  <tr>
    <td>4_4_5_1_5_1</td>
    <td>• represent transition rules using a transition function</td>
  </tr>
  <tr>
    <td>4_4_5_1_5_2</td>
    <td>• represent transition rules using a state transition diagram</td>
  </tr>
  <tr>
    <td>4_4_5_1_5_3</td>
    <td>• hand-trace simple Turing machines.</td>
  </tr>
  <tr>
    <td>4_4_5_1_6</td>
    <td>Be able to explain the importance of Turing machines and the Universal Turing machine to the subject of computation</td>
  </tr>
  <tr>
    <td>4_4_5_1_6_1</td>
    <td>x+ Turing machines provide a (general/formal) model of computation and provide a definition of what is computable.</td>
  </tr>
  <tr>
    <td>4_5</td>
    <td>Fundamentals of data representation</td>
  </tr>
  <tr>
    <td>4_5_1</td>
    <td>Number systems</td>
  </tr>
  <tr>
    <td>4_5_1_1</td>
    <td>Natural numbers</td>
  </tr>
  <tr>
    <td>4_5_1_1_1</td>
    <td>Be familiar with the concept of a natural number and the set ? of natural numbers (including zero).</td>
  </tr>
  <tr>
    <td>4_5_1_1_1_1</td>
    <td>x N = {0; 1; 2; 3; … }</td>
  </tr>
  <tr>
    <td>4_5_1_2</td>
    <td>Integer numbers </td>
  </tr>
  <tr>
    <td>4_5_1_2_1</td>
    <td>Be familiar with the concept of an integer and the set Z of integers.</td>
  </tr>
  <tr>
    <td>4_5_1_2_1_1</td>
    <td>x Z = { …; -3; -2; -1; 0; 1; 2; 3; … }</td>
  </tr>
  <tr>
    <td>4_5_1_3</td>
    <td>Rational numbers</td>
  </tr>
  <tr>
    <td>4_5_1_3_1</td>
    <td>Be familiar with the concept of a rational number and the set Q of rational numbers; and that this set includes the integers.</td>
  </tr>
  <tr>
    <td>4_5_1_3_1_1</td>
    <td>x ? is the set of numbers that can be written as fractions (ratios of integers). Since a number such as 7 can be written as 7/1; all integers are rational numbers.</td>
  </tr>
  <tr>
    <td>4_5_1_4</td>
    <td>Irrational numbers</td>
  </tr>
  <tr>
    <td>4_5_1_4_1</td>
    <td>Be familiar with the concept of an irrational number.</td>
  </tr>
  <tr>
    <td>4_5_1_4_1_1</td>
    <td>x An irrational number is one that cannot be written as a fraction; for example ?2.</td>
  </tr>
  <tr>
    <td>4_5_1_5</td>
    <td>Real numbers</td>
  </tr>
  <tr>
    <td>4_5_1_5_1</td>
    <td>Be familiar with the concept of a real number and the set ? of real numbers; which includes the natural numbers; the rational numbers; and the irrational numbers.</td>
  </tr>
  <tr>
    <td>4_5_1_5_1_1</td>
    <td>x R is the set of all &#x27;possible real world quantities&#x27;.</td>
  </tr>
  <tr>
    <td>4_5_1_6</td>
    <td>Ordinal numbers</td>
  </tr>
  <tr>
    <td>4_5_1_6_1</td>
    <td>Be familiar with the concept of ordinal numbers and their use to describe the numerical positions of objects.</td>
  </tr>
  <tr>
    <td>4_5_1_6_1_1</td>
    <td>x When objects are placed in order; ordinal numbers are used to tell their position. For example; if we have a well-ordered set S = {‘a’; ‘b’; ‘c’; ‘d’}; then ‘a’ is the 1st object; ‘b’ the 2nd; and so on.</td>
  </tr>
  <tr>
    <td>4_5_1_7</td>
    <td>Counting and measurement</td>
  </tr>
  <tr>
    <td>4_5_1_7_1</td>
    <td>Be familiar with the use of:</td>
  </tr>
  <tr>
    <td>4_5_1_7_1_1</td>
    <td>• natural numbers for counting</td>
  </tr>
  <tr>
    <td>4_5_1_7_1_2</td>
    <td>• real numbers for measurement.</td>
  </tr>
  <tr>
    <td>4_5_2</td>
    <td>Number bases</td>
  </tr>
  <tr>
    <td>4_5_2_1</td>
    <td>Number base</td>
  </tr>
  <tr>
    <td>4_5_2_1_1</td>
    <td>Be familiar with the concept of a number base; in particular:</td>
  </tr>
  <tr>
    <td>4_5_2_1_1_1</td>
    <td>• decimal (base 10)</td>
  </tr>
  <tr>
    <td>4_5_2_1_1_2</td>
    <td>• binary (base 2)</td>
  </tr>
  <tr>
    <td>4_5_2_1_1_3</td>
    <td>• hexadecimal (base 16).</td>
  </tr>
  <tr>
    <td>4_5_2_1_1_4</td>
    <td>x Students should be familiar with expressing a number’s base using a subscript.</td>
  </tr>
  <tr>
    <td>4_5_2_1_2</td>
    <td>Convert between decimal; binary and hexadecimal number bases.</td>
  </tr>
  <tr>
    <td>4_5_2_1_3</td>
    <td>Be familiar with; and able to use; hexadecimal as a shorthand for binary and to understand why it is used in this way.</td>
  </tr>
  <tr>
    <td>4_5_3</td>
    <td>Units of information</td>
  </tr>
  <tr>
    <td>4_5_3_1</td>
    <td>Bits and bytes</td>
  </tr>
  <tr>
    <td>4_5_3_1_1</td>
    <td>Know that:</td>
  </tr>
  <tr>
    <td>4_5_3_1_1_1</td>
    <td>• the bit is the fundamental unit of information</td>
  </tr>
  <tr>
    <td>4_5_3_1_1_2</td>
    <td>• a byte is a group of 8 bits.</td>
  </tr>
  <tr>
    <td>4_5_3_1_1_3</td>
    <td>x A bit is either 0 or 1.</td>
  </tr>
  <tr>
    <td>4_5_3_1_2</td>
    <td>Know that the 2n different values can be represented with n bits.</td>
  </tr>
  <tr>
    <td>4_5_3_1_2_1</td>
    <td>x For example; 3 bits can be configured in 23 = 8 different ways. 000; 001; 010; 011; 100; 101; 110; 111</td>
  </tr>
  <tr>
    <td>4_5_3_2</td>
    <td> Units</td>
  </tr>
  <tr>
    <td>4_5_3_2_1</td>
    <td>Know that quantities of bytes can be described using binary prefixes representing powers of 2 or using decimal prefixes representing powers of 10; eg one kibibyte is written as 1KiB = 210 B and one kilobyte is written as 1 kB = 103 B.</td>
  </tr>
  <tr>
    <td>4_5_3_2_2</td>
    <td>Know the names; symbols and corresponding powers of 2 for the binary prefixes:</td>
  </tr>
  <tr>
    <td>4_5_3_2_2_1</td>
    <td>• kibi; Ki - 210</td>
  </tr>
  <tr>
    <td>4_5_3_2_2_2</td>
    <td>• mebi; Mi - 220</td>
  </tr>
  <tr>
    <td>4_5_3_2_2_3</td>
    <td>• gibi; Gi - 230</td>
  </tr>
  <tr>
    <td>4_5_3_2_2_4</td>
    <td>• tebi; Ti - 240</td>
  </tr>
  <tr>
    <td>4_5_3_2_3</td>
    <td>Know the names; symbols and corresponding powers of 2 for the binary prefixes:</td>
  </tr>
  <tr>
    <td>4_5_3_2_3_1</td>
    <td>• kilo; k - 103</td>
  </tr>
  <tr>
    <td>4_5_3_2_3_2</td>
    <td>• mega; M - 106</td>
  </tr>
  <tr>
    <td>4_5_3_2_3_3</td>
    <td>• giga; G - 109</td>
  </tr>
  <tr>
    <td>4_5_3_2_3_4</td>
    <td>• tera; T - 1012</td>
  </tr>
  <tr>
    <td>4_5_3_2_3_5</td>
    <td>x Historically the terms kilobyte; megabyte; etc have often been used when kibibyte; mebibyte; etc are meant.</td>
  </tr>
  <tr>
    <td>4_5_4</td>
    <td>Binary number system</td>
  </tr>
  <tr>
    <td>4_5_4_1</td>
    <td>Unsigned binary</td>
  </tr>
  <tr>
    <td>4_5_4_1_1</td>
    <td>Know the difference between unsigned binary and signed binary.</td>
  </tr>
  <tr>
    <td>4_5_4_1_1_1</td>
    <td>x Students are expected to be able to convert between unsigned binary and decimal and vice versa.</td>
  </tr>
  <tr>
    <td>4_5_4_1_2</td>
    <td>Know that in unsigned binary the minimum and maximum values for a given number of bits; n; are 0 and 2n -1 respectively.</td>
  </tr>
  <tr>
    <td>4_5_4_2</td>
    <td>Unsigned binary arithmetic</td>
  </tr>
  <tr>
    <td>4_5_4_2_1</td>
    <td>Be able to:</td>
  </tr>
  <tr>
    <td>4_5_4_2_1_1</td>
    <td>• add two unsigned binary integers</td>
  </tr>
  <tr>
    <td>4_5_4_2_1_2</td>
    <td>• multiply two unsigned binary integers.</td>
  </tr>
  <tr>
    <td>4_5_4_3</td>
    <td>Signed binary using two’s complement</td>
  </tr>
  <tr>
    <td>4_5_4_3_1</td>
    <td>Know that signed binary can be used to represent negative integers and that one possible coding scheme is two’s complement.</td>
  </tr>
  <tr>
    <td>4_5_4_3_1_2</td>
    <td>x This is the only representation of negative integers that will be examined. Students are expected to be able to convert between signed binary and decimal and vice versa.</td>
  </tr>
  <tr>
    <td>4_5_4_3_2</td>
    <td>Know how to:</td>
  </tr>
  <tr>
    <td>4_5_4_3_2_1</td>
    <td>• represent negative and positive integers in two’s complement</td>
  </tr>
  <tr>
    <td>4_5_4_3_2_2</td>
    <td>• perform subtraction using two’s complement</td>
  </tr>
  <tr>
    <td>4_5_4_3_2_3</td>
    <td>• calculate the range of a given number of bits; n.</td>
  </tr>
  <tr>
    <td>4_5_4_4</td>
    <td>Numbers with a fractional part</td>
  </tr>
  <tr>
    <td>4_5_4_4_1</td>
    <td>Know how numbers with a fractional part can be represented in:</td>
  </tr>
  <tr>
    <td>4_5_4_4_1_1</td>
    <td>• fixed point form in binary in a given number of bits.</td>
  </tr>
  <tr>
    <td>4_5_4_4_1_2</td>
    <td>• floating point form in binary in a given number of bits.</td>
  </tr>
  <tr>
    <td>4_5_4_4_1_3</td>
    <td>x+ Students are not required to know the Instituteof Electrical and Electronic Engineers (IEEE)standard; only to know; understand and be able to use a simplified floating representation consisting of mantissa + exponent.</td>
  </tr>
  <tr>
    <td>4_5_4_4_2</td>
    <td>Be able to convert for each representation form:</td>
  </tr>
  <tr>
    <td>4_5_4_4_2_1</td>
    <td>• decimal to binary of a given number of bits</td>
  </tr>
  <tr>
    <td>4_5_4_4_2_2</td>
    <td>• binary to decimal of a given number of bits</td>
  </tr>
  <tr>
    <td>4_5_4_4_2_3</td>
    <td>x+ Exam questions on floating point numbers will use a format in which both the mantissa and exponent are represented using two&#x27;s complement.</td>
  </tr>
  <tr>
    <td>4_5_4_5</td>
    <td>Rounding errors</td>
  </tr>
  <tr>
    <td>4_5_4_5_1</td>
    <td>Know and be able to explain why both fixed point and floating point representation of decimal numbers may be inaccurate. </td>
  </tr>
  <tr>
    <td>4_5_4_5_1_1</td>
    <td>x+ Use binary fractions. For a real number to be represented exactly by the binary number system; it must be capable of being represented by a binary fraction in the given number of bits.</td>
  </tr>
  <tr>
    <td>4_5_4_5_1_2</td>
    <td>x+ Some values cannot ever be represented exactly; for example 0.110.</td>
  </tr>
  <tr>
    <td>4_5_4_6</td>
    <td>Absolute and relative errors</td>
  </tr>
  <tr>
    <td>4_5_4_6_1</td>
    <td>Be able to calculate the absolute error of numerical data stored and processed in computer systems.</td>
  </tr>
  <tr>
    <td>4_5_4_6_2</td>
    <td>Be able to calculate the relative error of numerical data stored and processed in computer systems.</td>
  </tr>
  <tr>
    <td>4_5_4_6_3</td>
    <td>Compare absolute and relative errors for large and small magnitude numbers; and numbers close to one.</td>
  </tr>
  <tr>
    <td>4_5_4_7</td>
    <td>Range and precision</td>
  </tr>
  <tr>
    <td>4_5_4_7_1</td>
    <td>Compare the advantages and disadvantages of fixed point and floating point forms in terms of range; precision and speed of calculation.</td>
  </tr>
  <tr>
    <td>4_5_4_8</td>
    <td>Normalisation of floating point form</td>
  </tr>
  <tr>
    <td>4_5_4_8_1</td>
    <td>Know why floating point numbers are normalised and be able to normalise unnormalised floating point numbers with positive or negative mantissas.</td>
  </tr>
  <tr>
    <td>4_5_4_9</td>
    <td>Underflow and overflow</td>
  </tr>
  <tr>
    <td>4_5_4_9_1</td>
    <td>Explain underflow and overflow and describe the circumstances in which they occur</td>
  </tr>
  <tr>
    <td>4_5_5</td>
    <td>Information coding systems</td>
  </tr>
  <tr>
    <td>4_5_5_1</td>
    <td>Character form of a decimal digit</td>
  </tr>
  <tr>
    <td>4_5_5_1_1</td>
    <td>Differentiate between the character code representation of a decimal digit and its pure binary representation.</td>
  </tr>
  <tr>
    <td>4_5_5_2</td>
    <td>ASCII and Unicode</td>
  </tr>
  <tr>
    <td>4_5_5_2_1</td>
    <td>Describe ASCII and Unicode coding systems for coding character data and explain why Unicode was introduced</td>
  </tr>
  <tr>
    <td>4_5_5_3</td>
    <td>Error checking and correction</td>
  </tr>
  <tr>
    <td>4_5_5_3_1</td>
    <td>Describe and explain the use of:</td>
  </tr>
  <tr>
    <td>4_5_5_3_1_1</td>
    <td>• parity bits</td>
  </tr>
  <tr>
    <td>4_5_5_3_1_2</td>
    <td>• majority voting</td>
  </tr>
  <tr>
    <td>4_5_5_3_1_3</td>
    <td>• check digits.</td>
  </tr>
  <tr>
    <td>4_5_5_3_1_4</td>
    <td>• checksums</td>
  </tr>
  <tr>
    <td>4_5_6</td>
    <td>Representing images; sound and other data</td>
  </tr>
  <tr>
    <td>4_5_6_1</td>
    <td>Bit patterns; images; sound and other data</td>
  </tr>
  <tr>
    <td>4_5_6_1_1</td>
    <td>Describe how bit patterns may represent other forms of data; including graphics and sound.</td>
  </tr>
  <tr>
    <td>4_5_6_2</td>
    <td>Analogue and digital</td>
  </tr>
  <tr>
    <td>4_5_6_2_1</td>
    <td>Understand the difference between analogue and digital</td>
  </tr>
  <tr>
    <td>4_5_6_2_1_1</td>
    <td>• data</td>
  </tr>
  <tr>
    <td>4_5_6_2_1_2</td>
    <td>• signals.</td>
  </tr>
  <tr>
    <td>4_5_6_3</td>
    <td>Analogue/digital conversion</td>
  </tr>
  <tr>
    <td>4_5_6_3_1</td>
    <td>Describe the principles of operation of:</td>
  </tr>
  <tr>
    <td>4_5_6_3_1_1</td>
    <td>• an analogue to digital converter (ADC)</td>
  </tr>
  <tr>
    <td>4_5_6_3_1_2</td>
    <td>• a digital to analogue converter (DAC).</td>
  </tr>
  <tr>
    <td>4_5_6_3_1_3</td>
    <td>Know that ADCs are used with analogue sensors.</td>
  </tr>
  <tr>
    <td>4_5_6_3_1_4</td>
    <td>Know that the most common use for a DAC is to convert a digital audio signal to an analogue signal.</td>
  </tr>
  <tr>
    <td>4_5_6_4</td>
    <td>Bitmapped graphics</td>
  </tr>
  <tr>
    <td>4_5_6_4_1</td>
    <td>Explain how bitmaps are represented.</td>
  </tr>
  <tr>
    <td>4_5_6_4_2</td>
    <td>Explain the following for bitmaps:</td>
  </tr>
  <tr>
    <td>4_5_6_4_2_1</td>
    <td>• resolution</td>
  </tr>
  <tr>
    <td>4_5_6_4_2_2</td>
    <td>• colour depth</td>
  </tr>
  <tr>
    <td>4_5_6_4_2_3</td>
    <td>• size in pixels.</td>
  </tr>
  <tr>
    <td>4_5_6_4_2_4</td>
    <td>x The size of an image is also alternatively sometimes described as the resolution of an image.</td>
  </tr>
  <tr>
    <td>4_5_6_4_2_5</td>
    <td>x Size of an image in pixels is width of image in pixels x height of image in pixels.</td>
  </tr>
  <tr>
    <td>4_5_6_4_2_6</td>
    <td>x Resolution is expressed as number of dots per inch where a dot is a pixel.</td>
  </tr>
  <tr>
    <td>4_5_6_4_2_7</td>
    <td>x Colour depth = number of bits stored for each pixel.</td>
  </tr>
  <tr>
    <td>4_5_6_4_3</td>
    <td>Calculate storage requirements for bitmapped images and be aware that bitmap image files may also contain metadata.</td>
  </tr>
  <tr>
    <td>4_5_6_4_3_1</td>
    <td>x Ignoring metadata; storage requirements = size in pixels x colour depth where size in pixels is width in pixels x height in pixels.</td>
  </tr>
  <tr>
    <td>4_5_6_4_4</td>
    <td>Be familiar with typical metadata.</td>
  </tr>
  <tr>
    <td>4_5_6_4_4_1</td>
    <td>x eg width; height; colour depth.</td>
  </tr>
  <tr>
    <td>4_5_6_5</td>
    <td>Vector graphics</td>
  </tr>
  <tr>
    <td>4_5_6_5_1</td>
    <td>Explain how vector graphics represents images using lists of objects.</td>
  </tr>
  <tr>
    <td>4_5_6_5_1_1</td>
    <td>x+ The properties of each geometric object/shape in the vector graphic image are stored as a list.</td>
  </tr>
  <tr>
    <td>4_5_6_5_2</td>
    <td>Give examples of typical properties of objects.</td>
  </tr>
  <tr>
    <td>4_5_6_5_3</td>
    <td>Use vector graphic primitives to create a simple vector graphic.</td>
  </tr>
  <tr>
    <td>4_5_6_6</td>
    <td>Vector graphics versus bitmapped graphics</td>
  </tr>
  <tr>
    <td>4_5_6_6_1</td>
    <td>Compare the vector graphics approach with the bitmapped graphics approach and understand the advantages and disadvantages of each.</td>
  </tr>
  <tr>
    <td>4_5_6_6_2</td>
    <td>Be aware of appropriate uses of each approach</td>
  </tr>
  <tr>
    <td>4_5_6_7</td>
    <td>Digital representation of sound</td>
  </tr>
  <tr>
    <td>4_5_6_7_1</td>
    <td>Describe the digital representation of sound in terms of:</td>
  </tr>
  <tr>
    <td>4_5_6_7_1_1</td>
    <td>• sample resolution</td>
  </tr>
  <tr>
    <td>4_5_6_7_1_2</td>
    <td>• sampling rate and the Nyquist theorem.</td>
  </tr>
  <tr>
    <td>4_5_6_7_2</td>
    <td>Calculate sound sample sizes in bytes.</td>
  </tr>
  <tr>
    <td>4_5_6_8</td>
    <td>Musical Instrument Digital Interface (MIDI)</td>
  </tr>
  <tr>
    <td>4_5_6_8_1</td>
    <td>Describe the purpose of MIDI and the use of event messages in MIDI.</td>
  </tr>
  <tr>
    <td>4_5_6_8_2</td>
    <td>Describe the advantages of using MIDI files for representing music.</td>
  </tr>
  <tr>
    <td>4_5_6_9</td>
    <td> Data compression</td>
  </tr>
  <tr>
    <td>4_5_6_9_1</td>
    <td>Know why images and sound files are often compressed and that other files; such as text files; can also be compressed.</td>
  </tr>
  <tr>
    <td>4_5_6_9_2</td>
    <td>Understand the difference between lossless and lossy compression and explain the advantages and disadvantages of each.</td>
  </tr>
  <tr>
    <td>4_5_6_9_3</td>
    <td>Explain the principles behind the following techniques for lossless compression:</td>
  </tr>
  <tr>
    <td>4_5_6_9_3_1</td>
    <td>• run length encoding (RLE)</td>
  </tr>
  <tr>
    <td>4_5_6_9_3_2</td>
    <td>• dictionary-based methods</td>
  </tr>
  <tr>
    <td>4_5_6_10</td>
    <td>Encryption</td>
  </tr>
  <tr>
    <td>4_5_6_10_1</td>
    <td>Understand what is meant by encryption and be able to define it.</td>
  </tr>
  <tr>
    <td>4_5_6_10_1_1</td>
    <td>x Students should be familiar with the terms cipher; plaintext and ciphertext.</td>
  </tr>
  <tr>
    <td>4_5_6_10_1_2</td>
    <td>x Caesar and Vernam ciphers are at opposite extremes. One offers perfect security; the other doesn’t. Between these two types are ciphers that are computationally secure – see below. Students will be assessed on the two types. Ciphers other than Caesar may be used to assess students&#x27;  understanding of the principles involved. These will be explained and be similar in terms of computational complexity.</td>
  </tr>
  <tr>
    <td>4_5_6_10_2</td>
    <td>Be familiar with Caesar cipher and be able to apply it to encrypt a plaintext message and decrypt a ciphertext.</td>
  </tr>
  <tr>
    <td>4_5_6_10_3</td>
    <td>Be able to explain why it is easily cracked.</td>
  </tr>
  <tr>
    <td>4_5_6_10_4</td>
    <td>Be familiar with Vernam cipher or one-time pad and be able to apply it to encrypt a plaintext message and decrypt a ciphertext.</td>
  </tr>
  <tr>
    <td>4_5_6_10_5</td>
    <td>Explain why Vernam cipher is considered as a cypher with perfect security.</td>
  </tr>
  <tr>
    <td>4_5_6_10_5_1</td>
    <td>x Since the key k is chosen uniformly at random; the ciphertext c is also distributed uniformly. The key k must be used once only. The key k is known as a one-time pad.</td>
  </tr>
  <tr>
    <td>4_5_6_10_6</td>
    <td>Compare Vernam cipher with ciphers that depend on computational security.</td>
  </tr>
  <tr>
    <td>4_5_6_10_6_1</td>
    <td>x Vernam cipher is the only one to have been mathematically proved to be completely secure. The worth of all other ciphers ever devised is based on computational security. In theory; every cryptographic algorithm except for Vernam cipher can be broken; given enough ciphertext and time.</td>
  </tr>
  <tr>
    <td>4_6</td>
    <td>Fundamentals of computer systems</td>
  </tr>
  <tr>
    <td>4_6_1</td>
    <td>Hardware and software</td>
  </tr>
  <tr>
    <td>4_6_1_1</td>
    <td>Relationship between hardware and software</td>
  </tr>
  <tr>
    <td>4_6_1_1_1</td>
    <td>Understand the relationship between hardware and software and be able to define the terms:</td>
  </tr>
  <tr>
    <td>4_6_1_1_1_1</td>
    <td>• hardware</td>
  </tr>
  <tr>
    <td>4_6_1_1_1_2</td>
    <td>• software.</td>
  </tr>
  <tr>
    <td>4_6_1_2</td>
    <td>Classification of software</td>
  </tr>
  <tr>
    <td>4_6_1_2_1</td>
    <td>Explain what is meant by:</td>
  </tr>
  <tr>
    <td>4_6_1_2_1_1</td>
    <td>• system software</td>
  </tr>
  <tr>
    <td>4_6_1_2_1_2</td>
    <td>• application software.</td>
  </tr>
  <tr>
    <td>4_6_1_2_2</td>
    <td>Understand the need for; and attributes of; different types of software.</td>
  </tr>
  <tr>
    <td>4_6_1_3</td>
    <td>System software</td>
  </tr>
  <tr>
    <td>4_6_1_3_1</td>
    <td>Understand the need for; and functions of the following system software:</td>
  </tr>
  <tr>
    <td>4_6_1_3_1</td>
    <td>• operating systems (OSs)</td>
  </tr>
  <tr>
    <td>4_6_1_3_1</td>
    <td>• utility programs</td>
  </tr>
  <tr>
    <td>4_6_1_3_1_1</td>
    <td>• libraries</td>
  </tr>
  <tr>
    <td>4_6_1_3_1_2</td>
    <td>• translators (compiler; assembler; interpreter).</td>
  </tr>
  <tr>
    <td>4_6_1_4</td>
    <td>Role of an operating system (OS)</td>
  </tr>
  <tr>
    <td>4_6_1_4_1</td>
    <td>Understand that a role of the operating system is to hide the complexities of the hardware.</td>
  </tr>
  <tr>
    <td>4_6_1_4_1_1</td>
    <td>Know that the OS handles resource management; managing hardware to allocate processors; memories and I/O devices among competing processes.</td>
  </tr>
  <tr>
    <td>4_6_2</td>
    <td>Classification of programming languages</td>
  </tr>
  <tr>
    <td>4_6_2_1</td>
    <td>Classification of programming languages</td>
  </tr>
  <tr>
    <td>4_6_2_1_1</td>
    <td>Show awareness of the development of types of programming languages and their classification into low-and high-level languages.</td>
  </tr>
  <tr>
    <td>4_6_2_1_2</td>
    <td>Know that low-level languages are considered to be:</td>
  </tr>
  <tr>
    <td>4_6_2_1_2_1</td>
    <td>• machine-code</td>
  </tr>
  <tr>
    <td>4_6_2_1_2_2</td>
    <td>• assembly language.</td>
  </tr>
  <tr>
    <td>4_6_2_1_3</td>
    <td>Know that high-level languages include imperative high level-language.</td>
  </tr>
  <tr>
    <td>4_6_2_1_4</td>
    <td>Describe machine-code language and assembly language.</td>
  </tr>
  <tr>
    <td>4_6_2_1_5</td>
    <td>Understand the advantages and disadvantages of machine-code and assembly language programming compared with high-level language programming.</td>
  </tr>
  <tr>
    <td>4_6_2_1_6</td>
    <td>Explain the term ‘imperative high-level language’ and its relationship to low-level languages</td>
  </tr>
  <tr>
    <td>4_6_3</td>
    <td>Types of program translator</td>
  </tr>
  <tr>
    <td>4_6_3_1</td>
    <td>Types of program translator</td>
  </tr>
  <tr>
    <td>4_6_3_1_1</td>
    <td>Understand the role of each of the following:</td>
  </tr>
  <tr>
    <td>4_6_3_1_1_1</td>
    <td>• assembler</td>
  </tr>
  <tr>
    <td>4_6_3_1_1_2</td>
    <td>• compiler</td>
  </tr>
  <tr>
    <td>4_6_3_1_1_3</td>
    <td>• interpreter.</td>
  </tr>
  <tr>
    <td>4_6_3_1_2</td>
    <td>Explain the differences between compilation and interpretation. Describe situations in which each would be appropriate.</td>
  </tr>
  <tr>
    <td>4_6_3_1_3</td>
    <td>Explain why an intermediate language such as bytecode is produced as the final output by some compilers and how it is subsequently used.</td>
  </tr>
  <tr>
    <td>4_6_3_1_4</td>
    <td>Understand the difference between source and object (executable) code.</td>
  </tr>
  <tr>
    <td>4_6_4</td>
    <td>Logic gates</td>
  </tr>
  <tr>
    <td>4_6_4_1</td>
    <td>Logic gates</td>
  </tr>
  <tr>
    <td>4_6_4_1_1</td>
    <td>Construct truth tables for the following logic gates:</td>
  </tr>
  <tr>
    <td>4_6_4_1_1_1</td>
    <td>• NOT</td>
  </tr>
  <tr>
    <td>4_6_4_1_1_2</td>
    <td>• AND</td>
  </tr>
  <tr>
    <td>4_6_4_1_1_3</td>
    <td>• OR</td>
  </tr>
  <tr>
    <td>4_6_4_1_1_4</td>
    <td>• XOR</td>
  </tr>
  <tr>
    <td>4_6_4_1_1_5</td>
    <td>• NAND</td>
  </tr>
  <tr>
    <td>4_6_4_1_1_6</td>
    <td>• NOR.</td>
  </tr>
  <tr>
    <td>4_6_4_1_1_7</td>
    <td>x Students should know and be able to use ANSI/IEEE standard 91-1984 Distinctive shape logic gate symbols for these logic gates.</td>
  </tr>
  <tr>
    <td>4_6_4_1_2</td>
    <td>Be familiar with drawing and interpreting logic gate circuit diagrams involving one or more of the above gates.</td>
  </tr>
  <tr>
    <td>4_6_4_1_3</td>
    <td>Complete a truth table for a given logic gate circuit.</td>
  </tr>
  <tr>
    <td>4_6_4_1_4</td>
    <td>Write a Boolean expression for a given logic gate circuit.</td>
  </tr>
  <tr>
    <td>4_6_4_1_5</td>
    <td>Draw an equivalent logic gate circuit for a given Boolean expression.</td>
  </tr>
  <tr>
    <td>4_6_4_1_6</td>
    <td>Recognise and trace the logic of the circuits of a half-adder and a full-adder.</td>
  </tr>
  <tr>
    <td>4_6_4_1_7</td>
    <td>Construct the circuit for a half-adder.</td>
  </tr>
  <tr>
    <td>4_6_4_1_8</td>
    <td>Be familiar with the use of the edge-triggered Dtype flip-flop as a memory unit.</td>
  </tr>
  <tr>
    <td>4_6_4_1_8_1</td>
    <td>x+ Knowledge of internal operation of this flip-flop is not required..</td>
  </tr>
  <tr>
    <td>4_6_5</td>
    <td>Boolean algebra</td>
  </tr>
  <tr>
    <td>4_6_5_1</td>
    <td>Using Boolean algebra</td>
  </tr>
  <tr>
    <td>4_6_5_1_1</td>
    <td>Be familiar with the use of Boolean identities and De Morgan’s laws to manipulate and simplify Boolean expressions.</td>
  </tr>
  <tr>
    <td>4_7</td>
    <td>Fundamentals of computer organisation and architecture</td>
  </tr>
  <tr>
    <td>4_7_1</td>
    <td>Internal hardware components of a computer</td>
  </tr>
  <tr>
    <td>4_7_1_1</td>
    <td>Internal hardware components of a computer</td>
  </tr>
  <tr>
    <td>4_7_1_1_1</td>
    <td>Have an understanding and knowledge of the basic internal components of a computer system.</td>
  </tr>
  <tr>
    <td>4_7_1_1_1_1</td>
    <td>x Although exam questions about specific machines will not be asked; it might be useful to base this section on the machines used at the centre.</td>
  </tr>
  <tr>
    <td>4_7_1_1_2</td>
    <td>Understand the role of the following components and how they relate to each other:</td>
  </tr>
  <tr>
    <td>4_7_1_1_2_1</td>
    <td>• processor</td>
  </tr>
  <tr>
    <td>4_7_1_1_2_2</td>
    <td>• main memory</td>
  </tr>
  <tr>
    <td>4_7_1_1_2_3</td>
    <td>• address bus</td>
  </tr>
  <tr>
    <td>4_7_1_1_2_4</td>
    <td>• data bus</td>
  </tr>
  <tr>
    <td>4_7_1_1_2_5</td>
    <td>• control bus</td>
  </tr>
  <tr>
    <td>4_7_1_1_2_6</td>
    <td>• I/O controllers.</td>
  </tr>
  <tr>
    <td>4_7_1_1_3</td>
    <td>Understand the need for; and means of; communication between components. In particular; understand the concept of a bus and how address; data and control buses are used.</td>
  </tr>
  <tr>
    <td>4_7_1_1_4</td>
    <td>Be able to explain the difference between von Neumann and Harvard architectures and describe where each is typically used.</td>
  </tr>
  <tr>
    <td>4_7_1_1_4_1</td>
    <td>x Embedded systems such as digital signal processing (DSP) systems use Harvard architecture processors extensively.</td>
  </tr>
  <tr>
    <td>4_7_1_1_4_2</td>
    <td>x Von Neumann architecture is used extensively in general purpose computing systems.</td>
  </tr>
  <tr>
    <td>4_7_1_1_5</td>
    <td>Understand the concept of addressable memory.</td>
  </tr>
  <tr>
    <td>4_7_2</td>
    <td>The stored program concept</td>
  </tr>
  <tr>
    <td>4_7_2_1</td>
    <td>The meaning of the stored program concept</td>
  </tr>
  <tr>
    <td>4_7_2_1_1</td>
    <td>Be able to describe the stored program concept: machine code instructions stored in main memory are fetched and executed serially by a processor that performs arithmetic and logical operations.</td>
  </tr>
  <tr>
    <td>4_7_3</td>
    <td>Structure and role of the processor and its components</td>
  </tr>
  <tr>
    <td>4_7_3_1</td>
    <td>The processor and its components</td>
  </tr>
  <tr>
    <td>4_7_3_1_1</td>
    <td>Explain the role and operation of a processor and its major components:</td>
  </tr>
  <tr>
    <td>4_7_3_1_1_1</td>
    <td>• arithmetic logic unit</td>
  </tr>
  <tr>
    <td>4_7_3_1_1_2</td>
    <td>• control unit</td>
  </tr>
  <tr>
    <td>4_7_3_1_1_3</td>
    <td>• clock</td>
  </tr>
  <tr>
    <td>4_7_3_1_1_4</td>
    <td>• general-purpose registers</td>
  </tr>
  <tr>
    <td>4_7_3_1_1_5</td>
    <td>• dedicated register program counter</td>
  </tr>
  <tr>
    <td>4_7_3_1_1_6</td>
    <td>• dedicated register current instruction register</td>
  </tr>
  <tr>
    <td>4_7_3_1_1_7</td>
    <td>• dedicated register memory address register</td>
  </tr>
  <tr>
    <td>4_7_3_1_1_8</td>
    <td>• dedicated register memory buffer register</td>
  </tr>
  <tr>
    <td>4_7_3_1_1_9</td>
    <td>• dedicated register status register.</td>
  </tr>
  <tr>
    <td>4_7_3_2</td>
    <td> The Fetch-Execute cycle and the role of registers within it</td>
  </tr>
  <tr>
    <td>4_7_3_2_1</td>
    <td>Explain how the Fetch-Execute cycle is used to execute machine code programs; including the stages in the cycle (fetch; decode; execute) and details of registers used.</td>
  </tr>
  <tr>
    <td>4_7_3_3</td>
    <td>The processor instruction set</td>
  </tr>
  <tr>
    <td>4_7_3_3_1</td>
    <td>Understand the term ‘processor instruction set’ and know that an instruction set is processor specific.</td>
  </tr>
  <tr>
    <td>4_7_3_3_2</td>
    <td>Know that instructions consist of an opcode and one or more operands (value; memory address or register).</td>
  </tr>
  <tr>
    <td>4_7_3_3_2_1</td>
    <td>x A simple model will be used in which the addressing mode will be incorporated into the bits allocated to the opcode so the latter defines both the basic machine operation and the addressing mode. Students will not be expected to define opcode; only interpret opcodes in the given context of a question.</td>
  </tr>
  <tr>
    <td>4_7_3_3_2_2</td>
    <td>x For example; 4 bits have been allocated to the opcode (3 bits for basic machine operation; eg ADD; and 1 bit for the addressing mode). 4 bits have been allocated to the operand; making the instruction; opcode + operand; 8 bits in length. In this example; </td>
  </tr>
  <tr>
    <td>4_7_3_3_2_3</td>
    <td>x 16 different opcodes are possible (2^4 = 16) {A diagram is shown in the specification]</td>
  </tr>
  <tr>
    <td>4_7_3_4</td>
    <td>Addressing modes</td>
  </tr>
  <tr>
    <td>4_7_3_4_1</td>
    <td>Understand and apply immediate and direct addressing modes.</td>
  </tr>
  <tr>
    <td>4_7_3_4_1_1</td>
    <td>x Immediate addressing: the operand is the datum.</td>
  </tr>
  <tr>
    <td>4_7_3_4_1_2</td>
    <td>x Direct addressing: the operand is the address of the datum. Address to be interpreted as meaning either main memory or register</td>
  </tr>
  <tr>
    <td>4_7_3_5</td>
    <td>Machine-code/assembly language operations</td>
  </tr>
  <tr>
    <td>4_7_3_5_1</td>
    <td>Understand and apply the basic machine-code operations of :</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_1</td>
    <td>• load</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_2</td>
    <td>• add</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_3</td>
    <td>• subtract</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_4</td>
    <td>• store</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_5</td>
    <td>• branching (conditional and unconditional)</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_6</td>
    <td>• compare</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_7</td>
    <td>• logical bitwise operators (AND; OR; NOT; XOR)</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_8</td>
    <td>• logical shift right</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_9</td>
    <td>• logical shift left</td>
  </tr>
  <tr>
    <td>4_7_3_5_1_10</td>
    <td>• halt.</td>
  </tr>
  <tr>
    <td>4_7_3_5_2</td>
    <td>Use the basic machine-code operations above when machine-code instructions are expressed in mnemonic form- assembly language; using immediate and direct addressing.</td>
  </tr>
  <tr>
    <td>4_7_3_6</td>
    <td>Interrupts</td>
  </tr>
  <tr>
    <td>4_7_3_6_1</td>
    <td>Describe the role of interrupts and interrupt service routines (ISRs); their effect on the Fetch-Execute cycle; and the need to save the volatile environment while the interrupt is being serviced</td>
  </tr>
  <tr>
    <td>4_7_3_7</td>
    <td>Factors affecting processor performance</td>
  </tr>
  <tr>
    <td>4_7_3_7_1</td>
    <td>Explain the effect on processor performance of:</td>
  </tr>
  <tr>
    <td>4_7_3_7_1_1</td>
    <td>• multiple cores</td>
  </tr>
  <tr>
    <td>4_7_3_7_1_2</td>
    <td>• cache memory</td>
  </tr>
  <tr>
    <td>4_7_3_7_1_3</td>
    <td>• clock speed</td>
  </tr>
  <tr>
    <td>4_7_3_7_1_4</td>
    <td>• word length</td>
  </tr>
  <tr>
    <td>4_7_3_7_1_5</td>
    <td>• address bus width</td>
  </tr>
  <tr>
    <td>4_7_3_7_1_6</td>
    <td>• data bus width.</td>
  </tr>
  <tr>
    <td> _7_4</td>
    <td>External hardware devices</td>
  </tr>
  <tr>
    <td>4_7_4_1</td>
    <td>Input and output devices</td>
  </tr>
  <tr>
    <td>4_7_4_1_1</td>
    <td>Know the main characteristics; purposes and suitability of the devices and understand their principles of operation</td>
  </tr>
  <tr>
    <td>4_7_4_1_1_1</td>
    <td>x Devices that need to be considered are: barcode reader; digital camera; laser printer; RFID.</td>
  </tr>
  <tr>
    <td>4_7_4_2</td>
    <td>Secondary storage devices</td>
  </tr>
  <tr>
    <td>4_7_4_2_1</td>
    <td>Explain the need for secondary storage within a computer system.</td>
  </tr>
  <tr>
    <td>4_7_4_2_2</td>
    <td>Know the main characteristics; purposes; suitability and understand the principles of operation of the following devices:</td>
  </tr>
  <tr>
    <td>4_7_4_2_2_1</td>
    <td>• hard disk</td>
  </tr>
  <tr>
    <td>4_7_4_2_2_2</td>
    <td>• optical disk</td>
  </tr>
  <tr>
    <td>4_7_4_2_2_3</td>
    <td>• solid-state disk (SSD).</td>
  </tr>
  <tr>
    <td>4_7_4_2_2_4</td>
    <td>x SSD = NAND flash memory + a controller that manages pages; and blocks and complexities of writing. Based on floating gate transistors that trap and store charge. A block; made up of many pages; cannot overwrite pages; page has to be erased before it can be written to but technology requires the whole block to be erased. Lower latency and faster transfer speeds than a magnetic disk drive.</td>
  </tr>
  <tr>
    <td>4_7_4_2_3</td>
    <td>Compare the capacity and speed of access of various media and make a judgement about their suitability for different applications.</td>
  </tr>
  <tr>
    <td>4_8</td>
    <td>Consequences of uses of computing</td>
  </tr>
  <tr>
    <td>4_8_1</td>
    <td>Individual (moral); social (ethical); legal and cultural issues and opportunities</td>
  </tr>
  <tr>
    <td>4_8_1_1</td>
    <td>Individual (moral); social (ethical); legal and cultural issues and opportunities</td>
  </tr>
  <tr>
    <td>4_8_1_1_1</td>
    <td>Show awareness of current individual (moral); social (ethical); legal and cultural opportunities and risks of computing.</td>
  </tr>
  <tr>
    <td>4_8_1_1_2</td>
    <td>Understand that developments in computer science and the digital technologies have dramatically altered the shape of communications and information flows in  ocieties; enabling massive transformations in the capacity to:</td>
  </tr>
  <tr>
    <td>4_8_1_1_2_1</td>
    <td>• monitor behaviour</td>
  </tr>
  <tr>
    <td>4_8_1_1_2_2</td>
    <td>• amass and analyse personal information</td>
  </tr>
  <tr>
    <td>4_8_1_1_2_3</td>
    <td>• distribute; publish; communicate and disseminate personal information.</td>
  </tr>
  <tr>
    <td>4_8_1_1_3</td>
    <td>Understand that computer scientists and software engineers therefore have power; as well as the responsibilities that go with it; in the algorithms that they devise and the code that they deploy.</td>
  </tr>
  <tr>
    <td>4_8_1_1_4</td>
    <td>Understand that software and their algorithms embed moral and cultural values.</td>
  </tr>
  <tr>
    <td>4_8_1_1_5</td>
    <td>Understand that the issue of scale; for software the whole world over; creates potential for individual computer scientists and software engineers to produce great good; but with it comes the ability to cause great harm.</td>
  </tr>
  <tr>
    <td>4_8_1_1_6</td>
    <td>Be able to discuss the challenges facing legislators in the digital age.</td>
  </tr>
  <tr>
    <td>4_8_1_1_6_1</td>
    <td>x Teachers may wish to employ two very powerful techniques; hypotheticals and case studies; to engage students in the issues.</td>
  </tr>
  <tr>
    <td>4_8_1_1_6_2</td>
    <td>x Hypotheticals allow students to isolate quickly important ethical principles in an artificially simplified context. For example; a teacher might ask students to explain and defend how; as a Google project manager; they would evaluate a proposal to bring Google’s Street View technology to a remote African village. What questions should be asked? Who should be consulted? What benefits; risks and safeguards considered? What are the trade-offs?</td>
  </tr>
  <tr>
    <td>4_8_1_1_6_3</td>
    <td>x Case studies allow students to confront the tricky interplay between the sometimes competing ethical values and principles relevant in real world settings. For example; the Google Street View case might be used to tease out the ethical conflicts between individual and cultural expectations; the principle of informed consent; Street View’s value as a service; its potential impact on human perceptions and behaviours; and its commercial value to Google and its shareholders. </td>
  </tr>
  <tr>
    <td>4_8_1_1_6_4</td>
    <td>x There are many resources available on the Internet to support teaching of this topic.</td>
  </tr>
  <tr>
    <td>4_9</td>
    <td>Fundamentals of communication and networking</td>
  </tr>
  <tr>
    <td>4_9_1</td>
    <td>Communication</td>
  </tr>
  <tr>
    <td>4_9_1_1</td>
    <td>Communication methods</td>
  </tr>
  <tr>
    <td>4_9_1_1_1</td>
    <td>Define serial and parallel transmission methods and discuss the advantages of serial over parallel transmission.</td>
  </tr>
  <tr>
    <td>4_9_1_1_2</td>
    <td>Define and compare synchronous and asynchronous data transmission. </td>
  </tr>
  <tr>
    <td>4_9_1_1_3</td>
    <td>Describe the purpose of start and stop bits in asynchronous data transmission.</td>
  </tr>
  <tr>
    <td>4_9_1_2</td>
    <td>Communication basics</td>
  </tr>
  <tr>
    <td>4_9_1_2_1</td>
    <td>Define:</td>
  </tr>
  <tr>
    <td>4_9_1_2_1_1</td>
    <td>• baud rate</td>
  </tr>
  <tr>
    <td>4_9_1_2_1_2</td>
    <td>• bit rate</td>
  </tr>
  <tr>
    <td>4_9_1_2_1_3</td>
    <td>• bandwidth</td>
  </tr>
  <tr>
    <td>4_9_1_2_1_4</td>
    <td>• latency</td>
  </tr>
  <tr>
    <td>4_9_1_2_1_5</td>
    <td>• protocol.</td>
  </tr>
  <tr>
    <td>4_9_1_2_2</td>
    <td>Differentiate between baud rate and bit rate.</td>
  </tr>
  <tr>
    <td>4_9_1_2_2_1</td>
    <td>Bit rate can be higher than baud rate if more than one bit is encoded in each signal change.</td>
  </tr>
  <tr>
    <td>4_9_1_2_3</td>
    <td>Understand the relationship between bit rate and bandwidth.</td>
  </tr>
  <tr>
    <td>4_9_1_2_3_1</td>
    <td>Bit rate is directly proportionate to bandwidth.</td>
  </tr>
  <tr>
    <td>4_9_2</td>
    <td>Networking</td>
  </tr>
  <tr>
    <td>4_9_2_1</td>
    <td> Network topology</td>
  </tr>
  <tr>
    <td>4_9_2_1_1</td>
    <td>Understand:</td>
  </tr>
  <tr>
    <td>4_9_2_1_1_1</td>
    <td>• physical star topology</td>
  </tr>
  <tr>
    <td>4_9_2_1_1_2</td>
    <td>• logical bus network topology</td>
  </tr>
  <tr>
    <td>4_9_2_1_1_3</td>
    <td>• differentiate between physical bus and logical bus</td>
  </tr>
  <tr>
    <td>4_9_2_1_1_4</td>
    <td>• explain the operation of both physical star and logical bus</td>
  </tr>
  <tr>
    <td>4_9_2_1_1_5</td>
    <td>x A network physically wired in star topology can behave logically as a bus network by using a bus protocol and appropriate physical switching.</td>
  </tr>
  <tr>
    <td>4_9_2_2</td>
    <td>Types of networking between hosts</td>
  </tr>
  <tr>
    <td>4_9_2_2_1</td>
    <td>Explain the following and describe situations where they might be used:</td>
  </tr>
  <tr>
    <td>4_9_2_2_1_1</td>
    <td>• peer-to-peer networking</td>
  </tr>
  <tr>
    <td>4_9_2_2_1_2</td>
    <td>• client-server networking.</td>
  </tr>
  <tr>
    <td>4_9_2_2_1_3</td>
    <td>x In a peer-to-peer network; each computer has equal status. In a client-server network; most computers are nominated as clients and one or more as servers. The clients request services from the servers; which provide these services; for example file server; email server.</td>
  </tr>
  <tr>
    <td>4_9_2_3</td>
    <td>Wireless networking</td>
  </tr>
  <tr>
    <td>4_9_2_3_1</td>
    <td>Explain the purpose of WiFi.</td>
  </tr>
  <tr>
    <td>4_9_2_3_1_1</td>
    <td>x A wireless local area network that is based on international standards.</td>
  </tr>
  <tr>
    <td>4_9_2_3_1_2</td>
    <td>x Used to enable devices to connect to a network wirelessly.</td>
  </tr>
  <tr>
    <td>4_9_2_3_2</td>
    <td>Be familiar with the components required for wireless networking.</td>
  </tr>
  <tr>
    <td>4_9_2_3_2_1</td>
    <td>x Wireless network adapter.</td>
  </tr>
  <tr>
    <td>4_9_2_3_2_2</td>
    <td>x Wireless access point</td>
  </tr>
  <tr>
    <td>4_9_2_3_3</td>
    <td>Be familiar with how wireless networks are secured.</td>
  </tr>
  <tr>
    <td>4_9_2_3_3_1</td>
    <td>x Strong encryption of transmitted data using WPA (Wifi Protected Access)/WPA2; SSID (Service Set Identifier) broadcast disabled; MAC (Media Access Control) address white list.</td>
  </tr>
  <tr>
    <td>4_9_2_3_4</td>
    <td>Explain the wireless protocol Carrier Sense Multiple Access with Collision Avoidance (CSMA/CA) with and without Request to Send/Clear to Send (RTS/CTS).</td>
  </tr>
  <tr>
    <td>4_9_2_3_4_1</td>
    <td>x Knowledge of Carrier Sense Multiple Access/Collection Detection (CSMA/CD) as used in; for example; Ethernet; is not required.</td>
  </tr>
  <tr>
    <td>4_9_2_3_5</td>
    <td>Be familiar with the purpose of Service Set Identifier (SSID).</td>
  </tr>
  <tr>
    <td>4_9_3</td>
    <td>The Internet</td>
  </tr>
  <tr>
    <td>4_9_3_1</td>
    <td>The Internet and how it works</td>
  </tr>
  <tr>
    <td>4_9_3_1_1</td>
    <td>Understand the structure of the Internet.</td>
  </tr>
  <tr>
    <td>4_9_3_1_2</td>
    <td>Understand the role of packet switching and routers.</td>
  </tr>
  <tr>
    <td>4_9_3_1_3</td>
    <td>Know the main components of a packet.</td>
  </tr>
  <tr>
    <td>4_9_3_1_4</td>
    <td>Define and Consider where and why the following are used.:</td>
  </tr>
  <tr>
    <td>4_9_3_1_4_1</td>
    <td>• router</td>
  </tr>
  <tr>
    <td>4_9_3_1_4_2</td>
    <td>• gateway.</td>
  </tr>
  <tr>
    <td>4_9_3_1_5</td>
    <td>Explain how routing is achieved across the Internet.</td>
  </tr>
  <tr>
    <td>4_9_3_1_6</td>
    <td>Describe the term &#x27;uniform resource locator&#x27; (URL) in the context of internetworking.</td>
  </tr>
  <tr>
    <td>4_9_3_1_7</td>
    <td>Explain the terms ‘fully qualified domain name’ (FQDN); ‘domain name’ and ‘IP address’.</td>
  </tr>
  <tr>
    <td>4_9_3_1_8</td>
    <td>Describe how domain names are organised.</td>
  </tr>
  <tr>
    <td>4_9_3_1_9</td>
    <td>Understand the purpose and function of the domain service and its reliance on the Domain Name Server (DNS) system.</td>
  </tr>
  <tr>
    <td>4_9_3_1_10</td>
    <td>Explain the service provided by Internet registries and why they are needed..</td>
  </tr>
  <tr>
    <td>4_9_3_2</td>
    <td>Internet security</td>
  </tr>
  <tr>
    <td>4_9_3_2_1</td>
    <td>Understand how a firewall works (packet filtering; proxy server; stateful inspection).</td>
  </tr>
  <tr>
    <td>4_9_3_2_2</td>
    <td>Explain symmetric and asymmetric (private/ public key) encryption and key exchange.</td>
  </tr>
  <tr>
    <td>4_9_3_2_3</td>
    <td>Explain how digital certificates and digital signatures are obtained and used.</td>
  </tr>
  <tr>
    <td>4_9_3_2_4</td>
    <td>Discuss worms; trojans and viruses; and the vulnerabilities that they exploit.</td>
  </tr>
  <tr>
    <td>4_9_3_2_5</td>
    <td>Discuss how improved code quality; monitoring and protection can be used to address worms; trojans and viruses.</td>
  </tr>
  <tr>
    <td>4_9_4</td>
    <td>The Transmission Control Protocol/Internet Protocol (TCP/IP) protocol</td>
  </tr>
  <tr>
    <td>4_9_4_1</td>
    <td>TCP/IP</td>
  </tr>
  <tr>
    <td>4_9_4_1_1</td>
    <td>Describe the role of the four layers of the TCP/IP stack (application; transport; network; link).</td>
  </tr>
  <tr>
    <td>4_9_4_1_2</td>
    <td>Describe the role of sockets in the TCP/IP stack.</td>
  </tr>
  <tr>
    <td>4_9_4_1_3</td>
    <td>Be familiar with the role of MAC (Media Access Control) addresses.</td>
  </tr>
  <tr>
    <td>4_9_4_1_4</td>
    <td>Explain what the well-known ports and client ports are used for and the differences between them.</td>
  </tr>
  <tr>
    <td>4_9_4_2</td>
    <td>Standard application layer protocols</td>
  </tr>
  <tr>
    <td>4_9_4_2_1</td>
    <td>Be familiar with the following protocols:</td>
  </tr>
  <tr>
    <td>4_9_4_2_1_1</td>
    <td>• FTP (File Transfer Protocol)</td>
  </tr>
  <tr>
    <td>4_9_4_2_1_2</td>
    <td>• HTTP (Hypertext Transfer Protocol)</td>
  </tr>
  <tr>
    <td>4_9_4_2_1_3</td>
    <td>• HTTPS (Hypertext Transfer Protocol Secure)</td>
  </tr>
  <tr>
    <td>4_9_4_2_1_4</td>
    <td>• POP3 (Post Office Protocol (v3))</td>
  </tr>
  <tr>
    <td>4_9_4_2_1_5</td>
    <td>• SMTP (Simple Mail Transfer Protocol)</td>
  </tr>
  <tr>
    <td>4_9_4_2_1_6</td>
    <td>• SSH (Secure Shell).</td>
  </tr>
  <tr>
    <td>4_9_4_2_2</td>
    <td>Be familiar with FTP client software and an FTP server; with regard to transferring files using anonymous and non-anonymous access.</td>
  </tr>
  <tr>
    <td>4_9_4_2_3</td>
    <td>Be familiar with how SSH is used for remote management.</td>
  </tr>
  <tr>
    <td>4_9_4_2_4</td>
    <td>Know how an SSH client is used to make a TCP connection to a remote port for the purpose of sending commands to this port using application level protocols such as GET for HTTP; SMTP commands for sending email and POP3 for retrieving email.</td>
  </tr>
  <tr>
    <td>4_9_4_2_5</td>
    <td>Be familiar with using SSH to log in securely to a remote computer and execute commands.</td>
  </tr>
  <tr>
    <td>4_9_4_2_6</td>
    <td>Explain the role of an email server in retrieving and sending email.</td>
  </tr>
  <tr>
    <td>4_9_4_2_7</td>
    <td>Explain the role of a web server in serving up web pages in text form.</td>
  </tr>
  <tr>
    <td>4_9_4_2_8</td>
    <td>Understand the role of a web browser in retrieving web pages and web page resources and rendering these accordingly.</td>
  </tr>
  <tr>
    <td>4_9_4_3</td>
    <td>IP address structure</td>
  </tr>
  <tr>
    <td>4_9_4_3_1</td>
    <td>Know that an IP address is split into a network identifier part and a host identifier part.</td>
  </tr>
  <tr>
    <td>4_9_4_4</td>
    <td>Subnet masking</td>
  </tr>
  <tr>
    <td>4_9_4_4_1</td>
    <td>Know that networks can be divided into subnets and know how a subnet mask is used to identify the network identifier part of the IP address.</td>
  </tr>
  <tr>
    <td>4_9_4_5</td>
    <td>IP standards</td>
  </tr>
  <tr>
    <td>4_9_4_5_1</td>
    <td> Know that there are currently two standards of IP address; v4 and v6. </td>
  </tr>
  <tr>
    <td>4_9_4_5_2</td>
    <td>Know why v6 was introduced</td>
  </tr>
  <tr>
    <td>4_9_4_6</td>
    <td>Public and private IP addresses</td>
  </tr>
  <tr>
    <td>4_9_4_6_1</td>
    <td>Distinguish between routable and non-routable IP addresses.</td>
  </tr>
  <tr>
    <td>4_9_4_7</td>
    <td>Dynamic Host Configuration Protocol (DHCP)</td>
  </tr>
  <tr>
    <td>4_9_4_7_1</td>
    <td>Understand the purpose and function of the DHCP system.</td>
  </tr>
  <tr>
    <td>4_9_4_8</td>
    <td>Network Address Translation (NAT)</td>
  </tr>
  <tr>
    <td>4_9_4_8_1</td>
    <td>Explain the basic concept of NAT and why it is used.</td>
  </tr>
  <tr>
    <td>4_9_4_9</td>
    <td>Port forwarding</td>
  </tr>
  <tr>
    <td>4_9_4_9_1</td>
    <td>Explain the basic concept of port forwarding and why it is used.</td>
  </tr>
  <tr>
    <td>4_9_4_10</td>
    <td>Client server model</td>
  </tr>
  <tr>
    <td>4_9_4_10_1</td>
    <td>Be familiar with the client server model.</td>
  </tr>
  <tr>
    <td>4_9_4_10_1</td>
    <td>x + Client sends a request message to server; server responds to request by replying with a response message to client.</td>
  </tr>
  <tr>
    <td>4_9_4_10_2</td>
    <td>Be familiar with the Websocket protocol and know why it is used and where it is used.</td>
  </tr>
  <tr>
    <td>4_9_4_10_2</td>
    <td>x+ The Websocket specification defines an API  (Application Programming Interface) establishing a full-duplex &#x27;socket&#x27; connection between a web browser and a server over TCP. This means that there is a persistent connection etween client and server; allowing both parties to send data at any time.</td>
  </tr>
  <tr>
    <td>4_9_4_10_3</td>
    <td>Be familiar with the principles of Web CRUD</td>
  </tr>
  <tr>
    <td>4_9_4_10_4</td>
    <td>Applications and REST</td>
  </tr>
  <tr>
    <td>4_9_4_10_5</td>
    <td>CRUD is an acronym for:</td>
  </tr>
  <tr>
    <td>4_9_4_10_5_1</td>
    <td>• C – Create</td>
  </tr>
  <tr>
    <td>4_9_4_10_5_2</td>
    <td>• R – Retrieve</td>
  </tr>
  <tr>
    <td>4_9_4_10_5_3</td>
    <td>• U – Update</td>
  </tr>
  <tr>
    <td>4_9_4_10_5</td>
    <td>• D – Delete</td>
  </tr>
  <tr>
    <td>4_9_4_10_6</td>
    <td>REST enables CRUD to be mapped to database functions (SQL) as follows:</td>
  </tr>
  <tr>
    <td>4_9_4_10_6_1</td>
    <td>• GET ? SELECT</td>
  </tr>
  <tr>
    <td>4_9_4_10_6_2</td>
    <td>• POST ? INSERT</td>
  </tr>
  <tr>
    <td>4_9_4_10_6_3</td>
    <td>• DELETE ? DELETE</td>
  </tr>
  <tr>
    <td>4_9_4_10_6_4</td>
    <td>• PUT ? UPDATE.</td>
  </tr>
  <tr>
    <td>4_9_4_10_6_5</td>
    <td>x+ understand the principle that database connected to browser using REST – Representational State Transfer - which relies on HTTP request methods</td>
  </tr>
  <tr>
    <td>4_9_4_10_6_6</td>
    <td>x+ understand the principle that REST allows JavaScript to talk to server through HTTP</td>
  </tr>
  <tr>
    <td>4_9_4_10_6_7</td>
    <td>x+ understand the principle that REST API (Application Programming Interface) created and run on server; browser Javascript calls API</td>
  </tr>
  <tr>
    <td>4_9_4_10_6_8</td>
    <td>x+ understand the principle that JSON (JavaScript Object Notation) or XML can be used to transmit data between a server and web application</td>
  </tr>
  <tr>
    <td>4_9_4_10_6_9</td>
    <td>x+ understand the principle that Javascript referenced by HTML file; eg index.html; is run in browser.formation</td>
  </tr>
  <tr>
    <td>4_9_4_10_7</td>
    <td>Compare JSON (Java script object notation) with XML</td>
  </tr>
  <tr>
    <td>4_9_4_10_7_1</td>
    <td>x+ JSON compared with XML is: easier for a human to read; more compact; easier to create; easier for computers to parse and therefore quicker to parse.</td>
  </tr>
  <tr>
    <td>4_9_4_11</td>
    <td>Thin- versus thick-client computing</td>
  </tr>
  <tr>
    <td>4_9_4_11_1</td>
    <td>Compare and contrast thin-client computing with thick-client computing.</td>
  </tr>
  <tr>
    <td>4_10</td>
    <td>Fundamentals of databases</td>
  </tr>
  <tr>
    <td>4_10_1</td>
    <td>Conceptual data models and entity relationship modelling</td>
  </tr>
  <tr>
    <td>4_10_1_1</td>
    <td>Conceptual data models and entity relationship modelling</td>
  </tr>
  <tr>
    <td>4_10_1_1_1</td>
    <td>Produce a data model from given data requirements for a simple scenario involving multiple entities.</td>
  </tr>
  <tr>
    <td>4_10_1_1_2</td>
    <td>Produce entity relationship diagrams representing a data model and entity descriptions in the form: Entity1 (Attribute1; Attribute2; .... ).</td>
  </tr>
  <tr>
    <td>4_10_1_1_2_1</td>
    <td>x+ Underlining can be used to identify the attribute(s) which form the entity identifier.</td>
  </tr>
  <tr>
    <td>4_10_2</td>
    <td>Relational databases</td>
  </tr>
  <tr>
    <td>4_10_2_1</td>
    <td>Relational databases</td>
  </tr>
  <tr>
    <td>4_10_2_1_1</td>
    <td>Explain the concept of a relational database.</td>
  </tr>
  <tr>
    <td>4_10_2_1_2</td>
    <td>Be able to define the terms:</td>
  </tr>
  <tr>
    <td>4_10_2_1_2_1</td>
    <td>• attribute</td>
  </tr>
  <tr>
    <td>4_10_2_1_2_2</td>
    <td>• primary key</td>
  </tr>
  <tr>
    <td>4_10_2_1_2_3</td>
    <td>• composite primary key</td>
  </tr>
  <tr>
    <td>4_10_2_1_2_4</td>
    <td>• foreign key.</td>
  </tr>
  <tr>
    <td>4_10_3_  </td>
    <td>Database design and normalisation techniques</td>
  </tr>
  <tr>
    <td>4_10_3_1</td>
    <td>Database design and normalisation techniques</td>
  </tr>
  <tr>
    <td>4_10_3_1_1</td>
    <td>Normalise relations to third normal form.</td>
  </tr>
  <tr>
    <td>4_10_3_1_1_1</td>
    <td>x+ Students should know what properties are possessed by a relation in third normal form</td>
  </tr>
  <tr>
    <td>4_10_3_1_2</td>
    <td>Understand why databases are normalised.</td>
  </tr>
  <tr>
    <td>4_10_4</td>
    <td>Structured Query Language (SQL)</td>
  </tr>
  <tr>
    <td>4_10_4_1</td>
    <td>Structured Query Language (SQL)</td>
  </tr>
  <tr>
    <td>4_10_4_1_1</td>
    <td>Be able to use SQL to retrieve; update; insert and delete data from multiple tables of a relational database.</td>
  </tr>
  <tr>
    <td>4_10_4_1_2</td>
    <td>Be able to use SQL to define a database table.</td>
  </tr>
  <tr>
    <td>4_10_5</td>
    <td>Client server databases</td>
  </tr>
  <tr>
    <td>4_10_5_1</td>
    <td>Client server databases</td>
  </tr>
  <tr>
    <td>4_10_5_1_1</td>
    <td>Know that a client server database system provides simultaneous access to the database for multiple clients.</td>
  </tr>
  <tr>
    <td>4_10_5_1_2</td>
    <td>Know how concurrent access can be controlled to preserve the integrity of the database. </td>
  </tr>
  <tr>
    <td>4_10_5_1_2_1</td>
    <td>x+ Concurrent access can result in the problem of updates being lost if two clients edit a record at the same time. This problem can be managed by the use of record locks; serialisation; timestamp ordering; commitment ordering.</td>
  </tr>
  <tr>
    <td>4_11</td>
    <td>Big Data</td>
  </tr>
  <tr>
    <td>4_11_1</td>
    <td>Big Data</td>
  </tr>
  <tr>
    <td>4_11_1_1</td>
    <td>Big Data</td>
  </tr>
  <tr>
    <td>4_11_1_1_1</td>
    <td>Know that &#x27;Big Data&#x27; is a catch-all term for data that won&#x27;t fit the usual containers. Big Data can be described in terms of: </td>
  </tr>
  <tr>
    <td>4_11_1_1_1_1</td>
    <td>• volume - too big to fit into a single server</td>
  </tr>
  <tr>
    <td>4_11_1_1_1_2</td>
    <td>• velocity - streaming data; milliseconds to seconds to respond</td>
  </tr>
  <tr>
    <td>4_11_1_1_1_3</td>
    <td>• variety - data in many forms such as structured; unstructured; text; multimedia. </td>
  </tr>
  <tr>
    <td>4_11_1_1_1_4</td>
    <td>x+ Whilst its size receives all the attention; the most difficult aspect of Big  Data really involves its lack of structure. This lack of structure poses  challenges because:  analysing the data is made significantly more difficult;  relational databases are not appropriate because they require the data to fit into a row-and-column format. </td>
  </tr>
  <tr>
    <td>4_11_1_1_1_5</td>
    <td>x+ Machine learning techniques are needed to discern patterns in the data and to extract useful information.</td>
  </tr>
  <tr>
    <td>4_11_1_1_1_6</td>
    <td>x+ &#x27;Big&#x27; is a relative term; but size impacts when the data doesn’t fit onto a single server because relational databases don’t scale well across multiple machines.</td>
  </tr>
  <tr>
    <td>4_11_1_1_1_7</td>
    <td>x+ Data from networked sensors; smartphones; video surveillance; mouse clicks etc are continuously streamed.</td>
  </tr>
  <tr>
    <td>4_11_1_1_2</td>
    <td>Know that when data sizes are so big as not to fit on to a single server:</td>
  </tr>
  <tr>
    <td>4_11_1_1_2_1</td>
    <td>• the processing must be distributed across more than one machine</td>
  </tr>
  <tr>
    <td>4_11_1_1_2_2</td>
    <td>• functional programming is a solution; because it makes it easier to write correct and efficient distributed code.</td>
  </tr>
  <tr>
    <td>4_11_1_1_3</td>
    <td>Know what features of functional programming make it easier to write:</td>
  </tr>
  <tr>
    <td>4_11_1_1_3_1</td>
    <td>• correct code</td>
  </tr>
  <tr>
    <td>4_11_1_1_3_2</td>
    <td>• code that can be distributed to run across more than one server.</td>
  </tr>
  <tr>
    <td>4_11_1_1_3_3</td>
    <td>x+ Functional programming languages support: immutable data structures; statelessness; higher-order functions.</td>
  </tr>
  <tr>
    <td>4_11_1_1_4</td>
    <td>Be familiar with the:</td>
  </tr>
  <tr>
    <td>4_11_1_1_4_1</td>
    <td>• fact-based model for representing data</td>
  </tr>
  <tr>
    <td>4_11_1_1_4_2</td>
    <td>• graph schema for capturing the structure of the dataset</td>
  </tr>
  <tr>
    <td>4_11_1_1_4_3</td>
    <td>• nodes; edges and properties in graph schema</td>
  </tr>
  <tr>
    <td>4_11_1_1_4_4</td>
    <td>x+ Each fact within a fact-based model captures a single piece of information</td>
  </tr>
  <tr>
    <td>4_12</td>
    <td>Fundamentals of functional programming</td>
  </tr>
  <tr>
    <td>4_12_1</td>
    <td>Functional programming paradigm</td>
  </tr>
  <tr>
    <td>4_12_1_1</td>
    <td>Function type</td>
  </tr>
  <tr>
    <td>4_12_1_1_1</td>
    <td> Know that a function; f; has a function type f: A ? B (where the type is A ? B; A is the argument type; and B is the result type).</td>
  </tr>
  <tr>
    <td>4_12_1_1_2</td>
    <td>Know that A is called the domain and B is called the co-domain.</td>
  </tr>
  <tr>
    <td>4_12_1_1_3</td>
    <td>Know that the domain and co-domain are always subsets of objects in some data type.</td>
  </tr>
  <tr>
    <td>4_12_1_1_3_1</td>
    <td>x+ Loosely speaking; a function is a rule that; for each element in some set A of inputs; assigns  an output chosen from set B; but without necessarily using every member of B. For example;f: {a;b;c;…z} ? {0;1;2;…;25} could use the rule hat maps a to 0; b to 1; and so on; using all values which are members of set B.</td>
  </tr>
  <tr>
    <td>4_12_1_1_3_2</td>
    <td>x+ The domain is a set from which the function’s input values are chosen.</td>
  </tr>
  <tr>
    <td>4_12_1_1_3_3</td>
    <td>x+ The co-domain is a set from which the function’s output values are chosen. Not all of the co-domain’s members need to be outputs.</td>
  </tr>
  <tr>
    <td>4_12_1_2</td>
    <td>First-class object</td>
  </tr>
  <tr>
    <td>4_12_1_2_1</td>
    <td>Know that a function is a first-class object in functional programming languages and in imperative programming languages that support such objects. </td>
  </tr>
  <tr>
    <td>4_12_1_2_1_1</td>
    <td>x+ This means that it can be an argument to another function as well as the result of a function call.</td>
  </tr>
  <tr>
    <td>4_12_1_2_1_2</td>
    <td>x+ First-class objects (or values) are objects which may:  appear in expressions;  be assigned to a variable;  be assigned as arguments;  be returned in function calls. For example; integers; floating-point values; characters and strings are first class objects in many programming languages.</td>
  </tr>
  <tr>
    <td>4_12_1_3</td>
    <td>Function application</td>
  </tr>
  <tr>
    <td>4_12_1_3_1</td>
    <td>Know that function application means a function applied to its arguments.</td>
  </tr>
  <tr>
    <td>4_12_1_3_1_1</td>
    <td>x+ The process of giving particular inputs to a function is called function application; for example add(3;4) represents the application of the function add to integer arguments 3 and 4.</td>
  </tr>
  <tr>
    <td>4_12_1_3_1_2</td>
    <td>x+ The type of the function is f: integer x integer ? integer where integer x integer is the Cartesian product of the set integer with itself.</td>
  </tr>
  <tr>
    <td>4_12_1_3_1_3</td>
    <td>x+ Although we would say that function f takes two arguments; in fact it takes only one argument; which is a pair; for example (3;4).</td>
  </tr>
  <tr>
    <td>4_12_1_4</td>
    <td>Partial function application</td>
  </tr>
  <tr>
    <td>4_12_1_4_1</td>
    <td>Know what is meant by partial function application for one; two and three argument functions and be able to use the notations shown opposite.</td>
  </tr>
  <tr>
    <td>4_12_1_4_1_1</td>
    <td>x+ The function add takes two integers as arguments and gives an integer as a result. Viewed as follows in the partial function application scheme: add:  nteger ? (integer ? integer) add 4 returns a function which when applied to another integer adds 4 to that integer. The brackets may be dropped so function add  becomes add: integer ? integer ? integer The function add is now viewed as taking one argument after another and returning a result of data type integer.</td>
  </tr>
  <tr>
    <td>4_12_1_5</td>
    <td>Composition of functions</td>
  </tr>
  <tr>
    <td>4_12_1_5_1</td>
    <td>Know what is meant by composition of functions.</td>
  </tr>
  <tr>
    <td>4_12_1_5_1_1</td>
    <td>x+ The operation functional composition combines two functions to get a new function. Given two functions f: A ? B g: B ? C function g ? f; called the composition of g and f; is a function whose domain is A and co-domain is C. If the domain and co-domains of f and g are ?; and f(x) = (x + 2) and g(y) = y3. Then g ? f = (x + 2)3 f is applied first and then g is applied to the result returned by f.</td>
  </tr>
  <tr>
    <td>4_12_2</td>
    <td>Writing functional programs</td>
  </tr>
  <tr>
    <td>4_12_2_1</td>
    <td>Functional language programs</td>
  </tr>
  <tr>
    <td>4_12_2_1_1</td>
    <td>Show experience of constructing simple programs in a functional programminglanguage.</td>
  </tr>
  <tr>
    <td>4_12_2_1_1_1</td>
    <td>x+ The following is a list of functional programming languages that could be used:: Haskell; Standard ML; Scheme; Lisp. Other languages with built-in support for programming in a functional paradigm as well as other paradigms are:Python; F#; C#; Scala; Java 8; Delphi XE versions onwards;• VB.NET 2008 onwards.</td>
  </tr>
  <tr>
    <td>4_12_2_1_2</td>
    <td>Higher-order functions.</td>
  </tr>
  <tr>
    <td>4_12_2_1_2_1</td>
    <td>A function is higher-order if it takes a function as an argument or returns a function as a result; or does both.</td>
  </tr>
  <tr>
    <td>4_12_2_1_3</td>
    <td>Have experience of using the following in a functional programming language:</td>
  </tr>
  <tr>
    <td>4_12_2_1_3_1</td>
    <td>• map</td>
  </tr>
  <tr>
    <td>4_12_2_1_3_2</td>
    <td>x+ map is the name of a higher-order function that applies a given function to each element of a list; returning a list of results.</td>
  </tr>
  <tr>
    <td>4_12_2_1_3_3</td>
    <td>• filter</td>
  </tr>
  <tr>
    <td>4_12_2_1_3_4</td>
    <td>x+ filter is the name of a higher-order function that processes a data structure; typically a list; in some order to produce a new data structure containing exactly those elements of the original data structure that match a given condition.</td>
  </tr>
  <tr>
    <td>4_12_2_1_3_5</td>
    <td>• reduce or fold.</td>
  </tr>
  <tr>
    <td>4_12_2_1_3_6</td>
    <td>x+ reduce or fold is the name of a higher-order function which reduces a list of values to a single value by repeatedly applying a combining function to the list values.</td>
  </tr>
  <tr>
    <td>4_12_3</td>
    <td>Lists in functional programming</td>
  </tr>
  <tr>
    <td>4_12_3_1</td>
    <td>List processing</td>
  </tr>
  <tr>
    <td>4_12_3_1_1</td>
    <td>Be familiar with representing a list as a concatenation of a head and a tail.</td>
  </tr>
  <tr>
    <td>4_12_3_1_2</td>
    <td>Know that the head is an element of a list and the tail is a list.</td>
  </tr>
  <tr>
    <td>4_12_3_1_3</td>
    <td>Know that a list can be empty. </td>
  </tr>
  <tr>
    <td>4_12_3_1_4</td>
    <td>Describe and apply the following operations:</td>
  </tr>
  <tr>
    <td>4_12_3_1_4_1</td>
    <td>• return head of list</td>
  </tr>
  <tr>
    <td>4_12_3_1_4_2</td>
    <td>• return tail of list</td>
  </tr>
  <tr>
    <td>4_12_3_1_4_3</td>
    <td>• test for empty list</td>
  </tr>
  <tr>
    <td>4_12_3_1_4_4</td>
    <td>• return length of list</td>
  </tr>
  <tr>
    <td>4_12_3_1_4_5</td>
    <td>• construct an empty list</td>
  </tr>
  <tr>
    <td>4_12_3_1_4_6</td>
    <td>• prepend an item to a list</td>
  </tr>
  <tr>
    <td>4_12_3_1_4_7</td>
    <td>• append an item to a list.</td>
  </tr>
  <tr>
    <td>4_12_3_1_5</td>
    <td>Have experience writing programs for the list operations mentioned above in a functional programming language or in a language with support for the functional paradigm.</td>
  </tr>
  <tr>
    <td>4_12_3_1_5_1</td>
    <td>x+ For example; in Haskell the list [4; 3; 5] can be written in the form head:tail where head is the first item in the list and tail is the remainder of the list. In the example; we have 4:[3; 5]. We call 4 the head of the list and [3; 5] the tail. [] is the empty list.</td>
  </tr>
  <tr>
    <td>4_13</td>
    <td>Systematic approach to problem solving</td>
  </tr>
  <tr>
    <td>4_13_1</td>
    <td>Aspects of software development</td>
  </tr>
  <tr>
    <td>4_13_1_1</td>
    <td>Analysis</td>
  </tr>
  <tr>
    <td>4_13_1_1_1</td>
    <td>Be aware that before a problem can be solved; it must be defined; the requirements of the system that solves the problem must be established and a data model created. Requirements of system must be established by interaction with the intended users of the system. The process of clarifying  requirements may involve prototyping/agile approach. </td>
  </tr>
  <tr>
    <td>4_13_1_1_1_1</td>
    <td>x+ students should have experience of using abstraction to model aspects of the external world in a program.</td>
  </tr>
  <tr>
    <td>4_13_1_2</td>
    <td>Design</td>
  </tr>
  <tr>
    <td>4_13_1_2_1</td>
    <td>Be aware that before constructing a solution; the solution should be designed and specified; for example planning data structures for the data model; designing algorithms; designing an appropriate modular structure for the solution and designing the human user interface.</td>
  </tr>
  <tr>
    <td>4_13_1_2_1_1</td>
    <td>x+ Students should have sufficient experience of successfully structuring programs into modular parts with clear documented interfaces to enable them to design appropriate modular structures for solutions.</td>
  </tr>
  <tr>
    <td>4_13_1_2_2</td>
    <td>Be aware that design can be an iterative process involving a prototyping/agile approach.</td>
  </tr>
  <tr>
    <td>4_13_1_3</td>
    <td>Implementation</td>
  </tr>
  <tr>
    <td>4_13_1_3_1</td>
    <td>Be aware that the models and algorithms need to be implemented in the form of data structures and code (instructions) that a computer can understand</td>
  </tr>
  <tr>
    <td>4_13_1_3_1_1</td>
    <td>x+ Students should have sufficient practice of writing; debugging and testing programs to enable them to develop the skills to articulate how programs work arguing for their correctness and efficiency using logical reasoning; test data and user feedback.</td>
  </tr>
  <tr>
    <td>4_13_1_3_2</td>
    <td>Be aware that the final solution may be arrived at using an iterative process employing prototyping/an agile approach with a focus on solving the critical path first.</td>
  </tr>
  <tr>
    <td>4_13_1_4</td>
    <td>Testing</td>
  </tr>
  <tr>
    <td>4_13_1_4_1</td>
    <td>Be aware that the implementation must be tested for the presence of errors; using selected test data covering normal (typical); boundary and erroneous data.</td>
  </tr>
  <tr>
    <td>4_13_1_4_1_1</td>
    <td>x+ Students should have practical experience of designing and applying test data; normal; boundary and erroneous to the testing of programs so that they are familiar with these test data types and the purpose of testing. </td>
  </tr>
  <tr>
    <td>4_13_1_4_2</td>
    <td>It should also undergo acceptance testing with the intended user(s) of the system to ensure that the intended solution meets its specification.</td>
  </tr>
  <tr>
    <td>4_13_1_4_1_1</td>
    <td>x+ Students will only need to provide evidence of user feedback not details of the tests carried out by the end user..</td>
  </tr>
  <tr>
    <td>4_13_1_5</td>
    <td>Evaluation</td>
  </tr>
  <tr>
    <td>4_13_1_5_1</td>
    <td>Know the criteria for evaluating a computer system.</td>
  </tr>
</table>
</body>
</html>
